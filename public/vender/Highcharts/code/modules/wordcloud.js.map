{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts JS v11.3.0 (2024-01-10)\n *\n * (c) 2016-2024 Highsoft AS\n * Authors: Jon Arild Nygard\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/wordcloud', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                window.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Series/DrawPointUtilities.js', [_modules['Core/Utilities.js']], function (U) {\n        /* *\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { isNumber } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Handles the drawing of a component.\n         * Can be used for any type of component that reserves the graphic property,\n         * and provides a shouldDraw on its context.\n         *\n         * @private\n         *\n         * @todo add type checking.\n         * @todo export this function to enable usage\n         */\n        function draw(point, params) {\n            const { animatableAttribs, onComplete, css, renderer } = params;\n            const animation = (point.series && point.series.chart.hasRendered) ?\n                // Chart-level animation on updates\n                void 0 :\n                // Series-level animation on new points\n                (point.series &&\n                    point.series.options.animation);\n            let graphic = point.graphic;\n            params.attribs = {\n                ...params.attribs,\n                'class': point.getClassName()\n            } || {};\n            if ((point.shouldDraw())) {\n                if (!graphic) {\n                    if (params.shapeType === 'text') {\n                        graphic = renderer.text();\n                    }\n                    else if (params.shapeType === 'image') {\n                        graphic = renderer.image(params.imageUrl || '')\n                            .attr(params.shapeArgs || {});\n                    }\n                    else {\n                        graphic = renderer[params.shapeType](params.shapeArgs || {});\n                    }\n                    point.graphic = graphic;\n                    graphic.add(params.group);\n                }\n                if (css) {\n                    graphic.css(css);\n                }\n                graphic\n                    .attr(params.attribs)\n                    .animate(animatableAttribs, params.isNew ? false : animation, onComplete);\n            }\n            else if (graphic) {\n                const destroy = () => {\n                    point.graphic = graphic = (graphic && graphic.destroy());\n                    if (typeof onComplete === 'function') {\n                        onComplete();\n                    }\n                };\n                // animate only runs complete callback if something was animated.\n                if (Object.keys(animatableAttribs).length) {\n                    graphic.animate(animatableAttribs, void 0, () => destroy());\n                }\n                else {\n                    destroy();\n                }\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const DrawPointUtilities = {\n            draw\n        };\n\n        return DrawPointUtilities;\n    });\n    _registerModule(_modules, 'Series/Wordcloud/WordcloudPoint.js', [_modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (SeriesRegistry, U) {\n        /* *\n         *\n         *  Experimental Highcharts module which enables visualization of a word cloud.\n         *\n         *  (c) 2016-2024 Highsoft AS\n         *  Authors: Jon Arild Nygard\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         * */\n        const { column: { prototype: { pointClass: ColumnPoint } } } = SeriesRegistry.seriesTypes;\n        const { extend } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        class WordcloudPoint extends ColumnPoint {\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            isValid() {\n                return true;\n            }\n        }\n        extend(WordcloudPoint.prototype, {\n            weight: 1\n        });\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return WordcloudPoint;\n    });\n    _registerModule(_modules, 'Series/Wordcloud/WordcloudSeriesDefaults.js', [], function () {\n        /* *\n         *\n         *  Experimental Highcharts module which enables visualization of a word cloud.\n         *\n         *  (c) 2016-2024 Highsoft AS\n         *  Authors: Jon Arild Nygard\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * A word cloud is a visualization of a set of words, where the size and\n         * placement of a word is determined by how it is weighted.\n         *\n         * @sample highcharts/demo/wordcloud Word Cloud chart\n         *\n         * @extends      plotOptions.column\n         * @excluding    allAreas, boostThreshold, clip, colorAxis, compare,\n         *               compareBase, crisp, cropThreshold, dataGrouping,\n         *               dataLabels, depth, dragDrop, edgeColor, findNearestPointBy,\n         *               getExtremesFromAll, grouping, groupPadding, groupZPadding,\n         *               joinBy, maxPointWidth, minPointLength, navigatorOptions,\n         *               negativeColor, pointInterval, pointIntervalUnit,\n         *               pointPadding, pointPlacement, pointRange, pointStart,\n         *               pointWidth, pointStart, pointWidth, shadow, showCheckbox,\n         *               showInNavigator, softThreshold, stacking, threshold,\n         *               zoneAxis, zones, dataSorting, boostBlending\n         * @product      highcharts\n         * @since        6.0.0\n         * @requires     modules/wordcloud\n         * @optionparent plotOptions.wordcloud\n         */\n        const WordcloudSeriesDefaults = {\n            /**\n             * If there is no space for a word on the playing field, then this\n             * option will allow the playing field to be extended to fit the word.\n             * If false then the word will be dropped from the visualization.\n             *\n             * NB! This option is currently not decided to be published in the API,\n             * and is therefore marked as private.\n             *\n             * @ignore-option\n             */\n            allowExtendPlayingField: true,\n            animation: {\n                /** @internal */\n                duration: 500\n            },\n            borderWidth: 0,\n            /**\n             * @ignore-option\n             */\n            clip: false,\n            colorByPoint: true,\n            cropThreshold: Infinity,\n            /**\n             * A threshold determining the minimum font size that can be applied to\n             * a word.\n             */\n            minFontSize: 1,\n            /**\n             * The word with the largest weight will have a font size equal to this\n             * value. The font size of a word is the ratio between its weight and\n             * the largest occuring weight, multiplied with the value of\n             * maxFontSize.\n             */\n            maxFontSize: 25,\n            /**\n             * This option decides which algorithm is used for placement, and\n             * rotation of a word. The choice of algorith is therefore a crucial\n             * part of the resulting layout of the wordcloud. It is possible for\n             * users to add their own custom placement strategies for use in word\n             * cloud. Read more about it in our\n             * [documentation](https://www.highcharts.com/docs/chart-and-series-types/word-cloud-series#custom-placement-strategies)\n             *\n             * @validvalue [\"center\", \"random\"]\n             */\n            placementStrategy: 'center',\n            /**\n             * Rotation options for the words in the wordcloud.\n             *\n             * @sample highcharts/plotoptions/wordcloud-rotation\n             *         Word cloud with rotation\n             */\n            rotation: {\n                /**\n                 * The smallest degree of rotation for a word.\n                 */\n                from: 0,\n                /**\n                 * The number of possible orientations for a word, within the range\n                 * of `rotation.from` and `rotation.to`. Must be a number larger\n                 * than 0.\n                 */\n                orientations: 2,\n                /**\n                 * The largest degree of rotation for a word.\n                 */\n                to: 90\n            },\n            showInLegend: false,\n            /**\n             * Spiral used for placing a word after the initial position\n             * experienced a collision with either another word or the borders.\n             * It is possible for users to add their own custom spiralling\n             * algorithms for use in word cloud. Read more about it in our\n             * [documentation](https://www.highcharts.com/docs/chart-and-series-types/word-cloud-series#custom-spiralling-algorithm)\n             *\n             * @validvalue [\"archimedean\", \"rectangular\", \"square\"]\n             */\n            spiral: 'rectangular',\n            /**\n             * CSS styles for the words.\n             *\n             * @type    {Highcharts.CSSObject}\n             * @default {\"fontFamily\":\"sans-serif\", \"fontWeight\": \"900\"}\n             */\n            style: {\n                /** @ignore-option */\n                fontFamily: 'sans-serif',\n                /** @ignore-option */\n                fontWeight: '900',\n                /** @ignore-option */\n                whiteSpace: 'nowrap'\n            },\n            tooltip: {\n                followPointer: true,\n                pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}: <b>{point.weight}</b><br/>'\n            }\n        };\n        /**\n         * A `wordcloud` series. If the [type](#series.wordcloud.type) option is not\n         * specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.wordcloud\n         * @exclude   dataSorting, boostThreshold, boostBlending\n         * @product   highcharts\n         * @requires  modules/wordcloud\n         * @apioption series.wordcloud\n         */\n        /**\n         * An array of data points for the series. For the `wordcloud` series type,\n         * points can be given in the following ways:\n         *\n         * 1. An array of arrays with 2 values. In this case, the values correspond to\n         *    `name,weight`.\n         *    ```js\n         *    data: [\n         *        ['Lorem', 4],\n         *        ['Ipsum', 1]\n         *    ]\n         *    ```\n         *\n         * 2. An array of objects with named values. The following snippet shows only a\n         *    few settings, see the complete options set below. If the total number of\n         *    data points exceeds the series'\n         *    [turboThreshold](#series.arearange.turboThreshold), this option is not\n         *    available.\n         *    ```js\n         *    data: [{\n         *        name: \"Lorem\",\n         *        weight: 4\n         *    }, {\n         *        name: \"Ipsum\",\n         *        weight: 1\n         *    }]\n         *    ```\n         *\n         * @type      {Array<Array<string,number>|*>}\n         * @extends   series.line.data\n         * @excluding drilldown, marker, x, y\n         * @product   highcharts\n         * @apioption series.wordcloud.data\n         */\n        /**\n         * The name decides the text for a word.\n         *\n         * @type      {string}\n         * @since     6.0.0\n         * @product   highcharts\n         * @apioption series.wordcloud.data.name\n         */\n        /**\n         * The weighting of a word. The weight decides the relative size of a word\n         * compared to the rest of the collection.\n         *\n         * @type      {number}\n         * @since     6.0.0\n         * @product   highcharts\n         * @apioption series.wordcloud.data.weight\n         */\n        ''; // detach doclets above\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return WordcloudSeriesDefaults;\n    });\n    _registerModule(_modules, 'Series/Wordcloud/WordcloudUtils.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (H, U) {\n        /* *\n         *\n         *  Experimental Highcharts module which enables visualization of a word cloud.\n         *\n         *  (c) 2016-2024 Highsoft AS\n         *  Authors: Jon Arild Nygard\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         * */\n        const { deg2rad } = H;\n        const { extend, find, isNumber, isObject, merge } = U;\n        /* *\n         *\n         * Functions\n         *\n         * */\n        /**\n         * Detects if there is a collision between two rectangles.\n         *\n         * @private\n         * @function isRectanglesIntersecting\n         *\n         * @param {Highcharts.PolygonBoxObject} r1\n         * First rectangle.\n         *\n         * @param {Highcharts.PolygonBoxObject} r2\n         * Second rectangle.\n         *\n         * @return {boolean}\n         * Returns true if the rectangles overlap.\n         */\n        function isRectanglesIntersecting(r1, r2) {\n            return !(r2.left > r1.right ||\n                r2.right < r1.left ||\n                r2.top > r1.bottom ||\n                r2.bottom < r1.top);\n        }\n        /**\n         * Calculates the normals to a line between two points.\n         *\n         * @private\n         * @function getNormals\n         * @param {Highcharts.PolygonPointObject} p1\n         *        Start point for the line. Array of x and y value.\n         * @param {Highcharts.PolygonPointObject} p2\n         *        End point for the line. Array of x and y value.\n         * @return {Highcharts.PolygonObject}\n         *         Returns the two normals in an array.\n         */\n        function getNormals(p1, p2) {\n            const dx = p2[0] - p1[0], // x2 - x1\n            dy = p2[1] - p1[1]; // y2 - y1\n            return [\n                [-dy, dx],\n                [dy, -dx]\n            ];\n        }\n        /**\n         * @private\n         */\n        function getAxesFromPolygon(polygon) {\n            let points, axes = polygon.axes || [];\n            if (!axes.length) {\n                axes = [];\n                points = points = polygon.concat([polygon[0]]);\n                points.reduce((p1, p2) => {\n                    const normals = getNormals(p1, p2), axis = normals[0]; // Use the left normal as axis.\n                    // Check that the axis is unique.\n                    if (!find(axes, (existing) => existing[0] === axis[0] &&\n                        existing[1] === axis[1])) {\n                        axes.push(axis);\n                    }\n                    // Return p2 to be used as p1 in next iteration.\n                    return p2;\n                });\n                polygon.axes = axes;\n            }\n            return axes;\n        }\n        /**\n         * Projects a polygon onto a coordinate.\n         *\n         * @private\n         * @function project\n         * @param {Highcharts.PolygonObject} polygon\n         * Array of points in a polygon.\n         * @param {Highcharts.PolygonPointObject} target\n         * The coordinate of pr\n         */\n        function project(polygon, target) {\n            const products = polygon.map((point) => {\n                const ax = point[0], ay = point[1], bx = target[0], by = target[1];\n                return ax * bx + ay * by;\n            });\n            return {\n                min: Math.min.apply(this, products),\n                max: Math.max.apply(this, products)\n            };\n        }\n        /**\n         * @private\n         */\n        function isPolygonsOverlappingOnAxis(axis, polygon1, polygon2) {\n            const projection1 = project(polygon1, axis), projection2 = project(polygon2, axis), isOverlapping = !(projection2.min > projection1.max ||\n                projection2.max < projection1.min);\n            return !isOverlapping;\n        }\n        /**\n         * Checks whether two convex polygons are colliding by using the Separating\n         * Axis Theorem.\n         *\n         * @private\n         * @function isPolygonsColliding\n         * @param {Highcharts.PolygonObject} polygon1\n         *        First polygon.\n         *\n         * @param {Highcharts.PolygonObject} polygon2\n         *        Second polygon.\n         *\n         * @return {boolean}\n         *         Returns true if they are colliding, otherwise false.\n         */\n        function isPolygonsColliding(polygon1, polygon2) {\n            // Get the axis from both polygons.\n            const axes1 = getAxesFromPolygon(polygon1), axes2 = getAxesFromPolygon(polygon2), axes = axes1.concat(axes2), overlappingOnAllAxes = !find(axes, (axis) => isPolygonsOverlappingOnAxis(axis, polygon1, polygon2));\n            return overlappingOnAllAxes;\n        }\n        /**\n         * Detects if a word collides with any previously placed words.\n         *\n         * @private\n         * @function intersectsAnyWord\n         *\n         * @param {Highcharts.Point} point\n         * Point which the word is connected to.\n         *\n         * @param {Array<Highcharts.Point>} points\n         * Previously placed points to check against.\n         *\n         * @return {boolean}\n         * Returns true if there is collision.\n         */\n        function intersectsAnyWord(point, points) {\n            const rect = point.rect, polygon = point.polygon, lastCollidedWith = point.lastCollidedWith, isIntersecting = function (p) {\n                let result = isRectanglesIntersecting(rect, p.rect);\n                if (result &&\n                    (point.rotation % 90 || p.rotation % 90)) {\n                    result = isPolygonsColliding(polygon, p.polygon);\n                }\n                return result;\n            };\n            let intersects = false;\n            // If the point has already intersected a different point, chances are\n            // they are still intersecting. So as an enhancement we check this\n            // first.\n            if (lastCollidedWith) {\n                intersects = isIntersecting(lastCollidedWith);\n                // If they no longer intersects, remove the cache from the point.\n                if (!intersects) {\n                    delete point.lastCollidedWith;\n                }\n            }\n            // If not already found, then check if we can find a point that is\n            // intersecting.\n            if (!intersects) {\n                intersects = !!find(points, function (p) {\n                    const result = isIntersecting(p);\n                    if (result) {\n                        point.lastCollidedWith = p;\n                    }\n                    return result;\n                });\n            }\n            return intersects;\n        }\n        /**\n         * Gives a set of cordinates for an Archimedian Spiral.\n         *\n         * @private\n         * @function archimedeanSpiral\n         *\n         * @param {number} attempt\n         * How far along the spiral we have traversed.\n         *\n         * @param {Highcharts.WordcloudSpiralParamsObject} [params]\n         * Additional parameters.\n         *\n         * @return {boolean|Highcharts.PositionObject}\n         * Resulting coordinates, x and y. False if the word should be dropped from\n         * the visualization.\n         */\n        function archimedeanSpiral(attempt, params) {\n            const field = params.field, maxDelta = (field.width * field.width) + (field.height * field.height), t = attempt * 0.8; // 0.2 * 4 = 0.8. Enlarging the spiral.\n            let result = false;\n            // Emergency brake. TODO make spiralling logic more foolproof.\n            if (attempt <= 10000) {\n                result = {\n                    x: t * Math.cos(t),\n                    y: t * Math.sin(t)\n                };\n                if (!(Math.min(Math.abs(result.x), Math.abs(result.y)) < maxDelta)) {\n                    result = false;\n                }\n            }\n            return result;\n        }\n        /**\n         * Gives a set of cordinates for an rectangular spiral.\n         *\n         * @private\n         * @function squareSpiral\n         *\n         * @param {number} attempt\n         * How far along the spiral we have traversed.\n         *\n         * @param {Highcharts.WordcloudSpiralParamsObject} [params]\n         * Additional parameters.\n         *\n         * @return {boolean|Highcharts.PositionObject}\n         * Resulting coordinates, x and y. False if the word should be dropped from\n         * the visualization.\n         */\n        function squareSpiral(attempt, params) {\n            const a = attempt * 4, k = Math.ceil((Math.sqrt(a) - 1) / 2), isBoolean = (x) => (typeof x === 'boolean');\n            let t = 2 * k + 1, m = Math.pow(t, 2), result = false;\n            t -= 1;\n            if (attempt <= 10000) {\n                if (isBoolean(result) && a >= m - t) {\n                    result = {\n                        x: k - (m - a),\n                        y: -k\n                    };\n                }\n                m -= t;\n                if (isBoolean(result) && a >= m - t) {\n                    result = {\n                        x: -k,\n                        y: -k + (m - a)\n                    };\n                }\n                m -= t;\n                if (isBoolean(result)) {\n                    if (a >= m - t) {\n                        result = {\n                            x: -k + (m - a),\n                            y: k\n                        };\n                    }\n                    else {\n                        result = {\n                            x: k,\n                            y: k - (m - a - t)\n                        };\n                    }\n                }\n                result.x *= 5;\n                result.y *= 5;\n            }\n            return result;\n        }\n        /**\n         * Gives a set of cordinates for an rectangular spiral.\n         *\n         * @private\n         * @function rectangularSpiral\n         *\n         * @param {number} attempt\n         * How far along the spiral we have traversed.\n         *\n         * @param {Highcharts.WordcloudSpiralParamsObject} [params]\n         * Additional parameters.\n         *\n         * @return {boolean|Higcharts.PositionObject}\n         * Resulting coordinates, x and y. False if the word should be dropped from\n         * the visualization.\n         */\n        function rectangularSpiral(attempt, params) {\n            const result = squareSpiral(attempt, params), field = params.field;\n            if (result) {\n                result.x *= field.ratioX;\n                result.y *= field.ratioY;\n            }\n            return result;\n        }\n        /**\n         * @private\n         * @function getRandomPosition\n         *\n         * @param {number} size\n         * Random factor.\n         *\n         * @return {number}\n         * Random position.\n         */\n        function getRandomPosition(size) {\n            return Math.round((size * (Math.random() + 0.5)) / 2);\n        }\n        /**\n         * Calculates the proper scale to fit the cloud inside the plotting area.\n         *\n         * @private\n         * @function getScale\n         *\n         * @param {number} targetWidth\n         * Width of target area.\n         *\n         * @param {number} targetHeight\n         * Height of target area.\n         *\n         * @param {Object} field\n         * The playing field.\n         *\n         * @return {number}\n         * Returns the value to scale the playing field up to the size of the target\n         * area.\n         */\n        function getScale(targetWidth, targetHeight, field) {\n            const height = Math.max(Math.abs(field.top), Math.abs(field.bottom)) * 2, width = Math.max(Math.abs(field.left), Math.abs(field.right)) * 2, scaleX = width > 0 ? 1 / width * targetWidth : 1, scaleY = height > 0 ? 1 / height * targetHeight : 1;\n            return Math.min(scaleX, scaleY);\n        }\n        /**\n         * Calculates what is called the playing field. The field is the area which\n         * all the words are allowed to be positioned within. The area is\n         * proportioned to match the target aspect ratio.\n         *\n         * @private\n         * @function getPlayingField\n         *\n         * @param {number} targetWidth\n         * Width of the target area.\n         *\n         * @param {number} targetHeight\n         * Height of the target area.\n         *\n         * @param {Array<Highcharts.Point>} data\n         * Array of points.\n         *\n         * @param {Object} data.dimensions\n         * The height and width of the word.\n         *\n         * @return {Object}\n         * The width and height of the playing field.\n         */\n        function getPlayingField(targetWidth, targetHeight, data) {\n            const info = data.reduce(function (obj, point) {\n                const dimensions = point.dimensions, x = Math.max(dimensions.width, dimensions.height);\n                // Find largest height.\n                obj.maxHeight = Math.max(obj.maxHeight, dimensions.height);\n                // Find largest width.\n                obj.maxWidth = Math.max(obj.maxWidth, dimensions.width);\n                // Sum up the total maximum area of all the words.\n                obj.area += x * x;\n                return obj;\n            }, {\n                maxHeight: 0,\n                maxWidth: 0,\n                area: 0\n            }), \n            /**\n             * Use largest width, largest height, or root of total area to give\n             * size to the playing field.\n             */\n            x = Math.max(info.maxHeight, // Have enough space for the tallest word\n            info.maxWidth, // Have enough space for the broadest word\n            // Adjust 15% to account for close packing of words\n            Math.sqrt(info.area) * 0.85), ratioX = targetWidth > targetHeight ? targetWidth / targetHeight : 1, ratioY = targetHeight > targetWidth ? targetHeight / targetWidth : 1;\n            return {\n                width: x * ratioX,\n                height: x * ratioY,\n                ratioX: ratioX,\n                ratioY: ratioY\n            };\n        }\n        /**\n         * Calculates a number of degrees to rotate, based upon a number of\n         * orientations within a range from-to.\n         *\n         * @private\n         * @function getRotation\n         *\n         * @param {number} [orientations]\n         * Number of orientations.\n         *\n         * @param {number} [index]\n         * Index of point, used to decide orientation.\n         *\n         * @param {number} [from]\n         * The smallest degree of rotation.\n         *\n         * @param {number} [to]\n         * The largest degree of rotation.\n         *\n         * @return {boolean|number}\n         * Returns the resulting rotation for the word. Returns false if invalid\n         * input parameters.\n         */\n        function getRotation(orientations, index, from, to) {\n            let result = false, // Default to false\n            range, intervals, orientation;\n            // Check if we have valid input parameters.\n            if (isNumber(orientations) &&\n                isNumber(index) &&\n                isNumber(from) &&\n                isNumber(to) &&\n                orientations > 0 &&\n                index > -1 &&\n                to > from) {\n                range = to - from;\n                intervals = range / (orientations - 1 || 1);\n                orientation = index % orientations;\n                result = from + (orientation * intervals);\n            }\n            return result;\n        }\n        /**\n         * Calculates the spiral positions and store them in scope for quick access.\n         *\n         * @private\n         * @function getSpiral\n         *\n         * @param {Function} fn\n         * The spiral function.\n         *\n         * @param {Object} params\n         * Additional parameters for the spiral.\n         *\n         * @return {Function}\n         * Function with access to spiral positions.\n         */\n        function getSpiral(fn, params) {\n            const length = 10000, arr = [];\n            for (let i = 1; i < length; i++) {\n                // @todo unnecessary amount of precaclulation\n                arr.push(fn(i, params));\n            }\n            return (attempt) => (attempt <= length ? arr[attempt - 1] : false);\n        }\n        /**\n         * Detects if a word is placed outside the playing field.\n         *\n         * @private\n         * @function outsidePlayingField\n         *\n         * @param {Highcharts.PolygonBoxObject} rect\n         * The word box.\n         *\n         * @param {Highcharts.WordcloudFieldObject} field\n         * The width and height of the playing field.\n         *\n         * @return {boolean}\n         * Returns true if the word is placed outside the field.\n         */\n        function outsidePlayingField(rect, field) {\n            const playingField = {\n                left: -(field.width / 2),\n                right: field.width / 2,\n                top: -(field.height / 2),\n                bottom: field.height / 2\n            };\n            return !(playingField.left < rect.left &&\n                playingField.right > rect.right &&\n                playingField.top < rect.top &&\n                playingField.bottom > rect.bottom);\n        }\n        /**\n         * @private\n         */\n        function movePolygon(deltaX, deltaY, polygon) {\n            return polygon.map(function (point) {\n                return [\n                    point[0] + deltaX,\n                    point[1] + deltaY\n                ];\n            });\n        }\n        /**\n         * Check if a point intersects with previously placed words, or if it goes\n         * outside the field boundaries. If a collision, then try to adjusts the\n         * position.\n         *\n         * @private\n         * @function intersectionTesting\n         *\n         * @param {Highcharts.Point} point\n         * Point to test for intersections.\n         *\n         * @param {Highcharts.WordcloudTestOptionsObject} options\n         * Options object.\n         *\n         * @return {boolean|Highcharts.PositionObject}\n         * Returns an object with how much to correct the positions. Returns false\n         * if the word should not be placed at all.\n         */\n        function intersectionTesting(point, options) {\n            const placed = options.placed, field = options.field, rectangle = options.rectangle, polygon = options.polygon, spiral = options.spiral, \n            // Make a copy to update values during intersection testing.\n            rect = point.rect = extend({}, rectangle);\n            let attempt = 1, delta = {\n                x: 0,\n                y: 0\n            };\n            point.polygon = polygon;\n            point.rotation = options.rotation;\n            /* while w intersects any previously placed words:\n                do {\n                move w a little bit along a spiral path\n                } while any part of w is outside the playing field and\n                        the spiral radius is still smallish */\n            while (delta !== false &&\n                (intersectsAnyWord(point, placed) ||\n                    outsidePlayingField(rect, field))) {\n                delta = spiral(attempt);\n                if (isObject(delta)) {\n                    // Update the DOMRect with new positions.\n                    rect.left = rectangle.left + delta.x;\n                    rect.right = rectangle.right + delta.x;\n                    rect.top = rectangle.top + delta.y;\n                    rect.bottom = rectangle.bottom + delta.y;\n                    point.polygon = movePolygon(delta.x, delta.y, polygon);\n                }\n                attempt++;\n            }\n            return delta;\n        }\n        /**\n         * Extends the playing field to have enough space to fit a given word.\n         *\n         * @private\n         * @function extendPlayingField\n         *\n         * @param {Highcharts.WordcloudFieldObject} field\n         * The width, height and ratios of a playing field.\n         *\n         * @param {Highcharts.PolygonBoxObject} rectangle\n         * The bounding box of the word to add space for.\n         *\n         * @return {Highcharts.WordcloudFieldObject}\n         * Returns the extended playing field with updated height and width.\n         */\n        function extendPlayingField(field, rectangle) {\n            let height, width, ratioX, ratioY, x, extendWidth, extendHeight, result;\n            if (isObject(field) && isObject(rectangle)) {\n                height = (rectangle.bottom - rectangle.top);\n                width = (rectangle.right - rectangle.left);\n                ratioX = field.ratioX;\n                ratioY = field.ratioY;\n                // Use the same variable to extend both the height and width.\n                x = ((width * ratioX) > (height * ratioY)) ? width : height;\n                // Multiply variable with ratios to preserve aspect ratio.\n                extendWidth = x * ratioX;\n                extendHeight = x * ratioY;\n                // Calculate the size of the new field after adding\n                // space for the word.\n                result = merge(field, {\n                    // Add space on the left and right.\n                    width: field.width + (extendWidth * 2),\n                    // Add space on the top and bottom.\n                    height: field.height + (extendHeight * 2)\n                });\n            }\n            else {\n                result = field;\n            }\n            // Return the new extended field.\n            return result;\n        }\n        /**\n         * If a rectangle is outside a give field, then the boundaries of the field\n         * is adjusted accordingly. Modifies the field object which is passed as the\n         * first parameter.\n         *\n         * @private\n         * @function updateFieldBoundaries\n         *\n         * @param {Highcharts.WordcloudFieldObject} field\n         * The bounding box of a playing field.\n         *\n         * @param {Highcharts.PolygonBoxObject} rectangle\n         * The bounding box for a placed point.\n         *\n         * @return {Highcharts.WordcloudFieldObject}\n         * Returns a modified field object.\n         */\n        function updateFieldBoundaries(field, rectangle) {\n            // @todo improve type checking.\n            if (!isNumber(field.left) || field.left > rectangle.left) {\n                field.left = rectangle.left;\n            }\n            if (!isNumber(field.right) || field.right < rectangle.right) {\n                field.right = rectangle.right;\n            }\n            if (!isNumber(field.top) || field.top > rectangle.top) {\n                field.top = rectangle.top;\n            }\n            if (!isNumber(field.bottom) || field.bottom < rectangle.bottom) {\n                field.bottom = rectangle.bottom;\n            }\n            return field;\n        }\n        /**\n         * Alternative solution to correctFloat.\n         * E.g Highcharts.correctFloat(123, 2) returns 120, when it should be 123.\n         *\n         * @private\n         * @function correctFloat\n         */\n        function correctFloat(number, precision) {\n            const p = isNumber(precision) ? precision : 14, magnitude = Math.pow(10, p);\n            return Math.round(number * magnitude) / magnitude;\n        }\n        /**\n         * @private\n         */\n        function getBoundingBoxFromPolygon(points) {\n            return points.reduce(function (obj, point) {\n                const x = point[0], y = point[1];\n                obj.left = Math.min(x, obj.left);\n                obj.right = Math.max(x, obj.right);\n                obj.bottom = Math.max(y, obj.bottom);\n                obj.top = Math.min(y, obj.top);\n                return obj;\n            }, {\n                left: Number.MAX_VALUE,\n                right: -Number.MAX_VALUE,\n                bottom: -Number.MAX_VALUE,\n                top: Number.MAX_VALUE\n            });\n        }\n        /**\n         * @private\n         */\n        function getPolygon(x, y, width, height, rotation) {\n            const origin = [x, y], left = x - (width / 2), right = x + (width / 2), top = y - (height / 2), bottom = y + (height / 2), polygon = [\n                [left, top],\n                [right, top],\n                [right, bottom],\n                [left, bottom]\n            ];\n            return polygon.map(function (point) {\n                return rotate2DToPoint(point, origin, -rotation);\n            });\n        }\n        /**\n         * Rotates a point clockwise around the origin.\n         *\n         * @private\n         * @function rotate2DToOrigin\n         * @param {Highcharts.PolygonPointObject} point\n         *        The x and y coordinates for the point.\n         * @param {number} angle\n         *        The angle of rotation.\n         * @return {Highcharts.PolygonPointObject}\n         *         The x and y coordinate for the rotated point.\n         */\n        function rotate2DToOrigin(point, angle) {\n            const x = point[0], y = point[1], rad = deg2rad * -angle, cosAngle = Math.cos(rad), sinAngle = Math.sin(rad);\n            return [\n                correctFloat(x * cosAngle - y * sinAngle),\n                correctFloat(x * sinAngle + y * cosAngle)\n            ];\n        }\n        /**\n         * Rotate a point clockwise around another point.\n         *\n         * @private\n         * @function rotate2DToPoint\n         * @param {Highcharts.PolygonPointObject} point\n         *        The x and y coordinates for the point.\n         * @param {Highcharts.PolygonPointObject} origin\n         *        The point to rotate around.\n         * @param {number} angle\n         *        The angle of rotation.\n         * @return {Highcharts.PolygonPointObject}\n         *         The x and y coordinate for the rotated point.\n         */\n        function rotate2DToPoint(point, origin, angle) {\n            const x = point[0] - origin[0], y = point[1] - origin[1], rotated = rotate2DToOrigin([x, y], angle);\n            return [\n                rotated[0] + origin[0],\n                rotated[1] + origin[1]\n            ];\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const WordcloudUtils = {\n            archimedeanSpiral,\n            extendPlayingField,\n            getBoundingBoxFromPolygon,\n            getPlayingField,\n            getPolygon,\n            getRandomPosition,\n            getRotation,\n            getScale,\n            getSpiral,\n            intersectionTesting,\n            isPolygonsColliding,\n            isRectanglesIntersecting,\n            rectangularSpiral,\n            rotate2DToOrigin,\n            rotate2DToPoint,\n            squareSpiral,\n            updateFieldBoundaries\n        };\n\n        return WordcloudUtils;\n    });\n    _registerModule(_modules, 'Series/Wordcloud/WordcloudSeries.js', [_modules['Series/DrawPointUtilities.js'], _modules['Core/Globals.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js'], _modules['Series/Wordcloud/WordcloudPoint.js'], _modules['Series/Wordcloud/WordcloudSeriesDefaults.js'], _modules['Series/Wordcloud/WordcloudUtils.js']], function (DPU, H, SeriesRegistry, U, WordcloudPoint, WordcloudSeriesDefaults, WU) {\n        /* *\n         *\n         *  Experimental Highcharts module which enables visualization of a word cloud.\n         *\n         *  (c) 2016-2024 Highsoft AS\n         *  Authors: Jon Arild Nygard\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         * */\n        const { noop } = H;\n        const { column: ColumnSeries } = SeriesRegistry.seriesTypes;\n        const { extend, isArray, isNumber, isObject, merge } = U;\n        const { archimedeanSpiral, extendPlayingField, getBoundingBoxFromPolygon, getPlayingField, getPolygon, getRandomPosition, getRotation, getScale, getSpiral, intersectionTesting, isPolygonsColliding, rectangularSpiral, rotate2DToOrigin, rotate2DToPoint, squareSpiral, updateFieldBoundaries } = WU;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.wordcloud\n         *\n         * @augments Highcharts.Series\n         */\n        class WordcloudSeries extends ColumnSeries {\n            /**\n             *\n             * Functions\n             *\n             */\n            pointAttribs(point, state) {\n                const attribs = H.seriesTypes.column.prototype\n                    .pointAttribs.call(this, point, state);\n                delete attribs.stroke;\n                delete attribs['stroke-width'];\n                return attribs;\n            }\n            /**\n             * Calculates the fontSize of a word based on its weight.\n             *\n             * @private\n             * @function Highcharts.Series#deriveFontSize\n             *\n             * @param {number} [relativeWeight=0]\n             * The weight of the word, on a scale 0-1.\n             *\n             * @param {number} [maxFontSize=1]\n             * The maximum font size of a word.\n             *\n             * @param {number} [minFontSize=1]\n             * The minimum font size of a word.\n             *\n             * @return {number}\n             * Returns the resulting fontSize of a word. If minFontSize is larger then\n             * maxFontSize the result will equal minFontSize.\n             */\n            deriveFontSize(relativeWeight, maxFontSize, minFontSize) {\n                const weight = isNumber(relativeWeight) ? relativeWeight : 0, max = isNumber(maxFontSize) ? maxFontSize : 1, min = isNumber(minFontSize) ? minFontSize : 1;\n                return Math.floor(Math.max(min, weight * max));\n            }\n            drawPoints() {\n                const series = this, hasRendered = series.hasRendered, xAxis = series.xAxis, yAxis = series.yAxis, chart = series.chart, group = series.group, options = series.options, animation = options.animation, allowExtendPlayingField = options.allowExtendPlayingField, renderer = chart.renderer, placed = [], placementStrategy = series.placementStrategy[options.placementStrategy], rotation = options.rotation, weights = series.points.map(function (p) {\n                    return p.weight;\n                }), maxWeight = Math.max.apply(null, weights), \n                // concat() prevents from sorting the original array.\n                points = series.points.concat().sort((a, b) => (b.weight - a.weight // Sort descending\n                ));\n                let testElement = renderer.text().add(group), field;\n                // Reset the scale before finding the dimensions (#11993).\n                // SVGGRaphicsElement.getBBox() (used in SVGElement.getBBox(boolean))\n                // returns slightly different values for the same element depending on\n                // whether it is rendered in a group which has already defined scale\n                // (e.g. 6) or in the group without a scale (scale = 1).\n                series.group.attr({\n                    scaleX: 1,\n                    scaleY: 1\n                });\n                // Get the dimensions for each word.\n                // Used in calculating the playing field.\n                for (const point of points) {\n                    const relativeWeight = 1 / maxWeight * point.weight, fontSize = series.deriveFontSize(relativeWeight, options.maxFontSize, options.minFontSize), css = extend({\n                        fontSize: fontSize + 'px'\n                    }, options.style);\n                    testElement.css(css).attr({\n                        x: 0,\n                        y: 0,\n                        text: point.name\n                    });\n                    const bBox = testElement.getBBox(true);\n                    point.dimensions = {\n                        height: bBox.height,\n                        width: bBox.width\n                    };\n                }\n                // Calculate the playing field.\n                field = getPlayingField(xAxis.len, yAxis.len, points);\n                const spiral = getSpiral(series.spirals[options.spiral], {\n                    field: field\n                });\n                // Draw all the points.\n                for (const point of points) {\n                    const relativeWeight = 1 / maxWeight * point.weight, fontSize = series.deriveFontSize(relativeWeight, options.maxFontSize, options.minFontSize), css = extend({\n                        fontSize: fontSize + 'px'\n                    }, options.style), placement = placementStrategy(point, {\n                        data: points,\n                        field: field,\n                        placed: placed,\n                        rotation: rotation\n                    }), attr = extend(series.pointAttribs(point, (point.selected && 'select')), {\n                        align: 'center',\n                        'alignment-baseline': 'middle',\n                        'dominant-baseline': 'middle',\n                        x: placement.x,\n                        y: placement.y,\n                        text: point.name,\n                        rotation: isNumber(placement.rotation) ?\n                            placement.rotation :\n                            void 0\n                    }), polygon = getPolygon(placement.x, placement.y, point.dimensions.width, point.dimensions.height, placement.rotation), rectangle = getBoundingBoxFromPolygon(polygon);\n                    let delta = intersectionTesting(point, {\n                        rectangle: rectangle,\n                        polygon: polygon,\n                        field: field,\n                        placed: placed,\n                        spiral: spiral,\n                        rotation: placement.rotation\n                    }), animate;\n                    // If there is no space for the word, extend the playing field.\n                    if (!delta && allowExtendPlayingField) {\n                        // Extend the playing field to fit the word.\n                        field = extendPlayingField(field, rectangle);\n                        // Run intersection testing one more time to place the word.\n                        delta = intersectionTesting(point, {\n                            rectangle: rectangle,\n                            polygon: polygon,\n                            field: field,\n                            placed: placed,\n                            spiral: spiral,\n                            rotation: placement.rotation\n                        });\n                    }\n                    // Check if point was placed, if so delete it, otherwise place it\n                    // on the correct positions.\n                    if (isObject(delta)) {\n                        attr.x = (attr.x || 0) + delta.x;\n                        attr.y = (attr.y || 0) + delta.y;\n                        rectangle.left += delta.x;\n                        rectangle.right += delta.x;\n                        rectangle.top += delta.y;\n                        rectangle.bottom += delta.y;\n                        field = updateFieldBoundaries(field, rectangle);\n                        placed.push(point);\n                        point.isNull = false;\n                        point.isInside = true; // #15447\n                    }\n                    else {\n                        point.isNull = true;\n                    }\n                    if (animation) {\n                        // Animate to new positions\n                        animate = {\n                            x: attr.x,\n                            y: attr.y\n                        };\n                        // Animate from center of chart\n                        if (!hasRendered) {\n                            attr.x = 0;\n                            attr.y = 0;\n                            // or animate from previous position\n                        }\n                        else {\n                            delete attr.x;\n                            delete attr.y;\n                        }\n                    }\n                    DPU.draw(point, {\n                        animatableAttribs: animate,\n                        attribs: attr,\n                        css: css,\n                        group: group,\n                        renderer: renderer,\n                        shapeArgs: void 0,\n                        shapeType: 'text'\n                    });\n                }\n                // Destroy the element after use.\n                testElement = testElement.destroy();\n                // Scale the series group to fit within the plotArea.\n                const scale = getScale(xAxis.len, yAxis.len, field);\n                series.group.attr({\n                    scaleX: scale,\n                    scaleY: scale\n                });\n            }\n            hasData() {\n                const series = this;\n                return (isObject(series) &&\n                    series.visible === true &&\n                    isArray(series.points) &&\n                    series.points.length > 0);\n            }\n            getPlotBox() {\n                const series = this, chart = series.chart, inverted = chart.inverted, \n                // Swap axes for inverted (#2339)\n                xAxis = series[(inverted ? 'yAxis' : 'xAxis')], yAxis = series[(inverted ? 'xAxis' : 'yAxis')], width = xAxis ? xAxis.len : chart.plotWidth, height = yAxis ? yAxis.len : chart.plotHeight, x = xAxis ? xAxis.left : chart.plotLeft, y = yAxis ? yAxis.top : chart.plotTop;\n                return {\n                    translateX: x + (width / 2),\n                    translateY: y + (height / 2),\n                    scaleX: 1,\n                    scaleY: 1\n                };\n            }\n        }\n        /* *\n         *\n         *  Static properties\n         *\n         * */\n        WordcloudSeries.defaultOptions = merge(ColumnSeries.defaultOptions, WordcloudSeriesDefaults);\n        extend(WordcloudSeries.prototype, {\n            animate: noop,\n            animateDrilldown: noop,\n            animateDrillupFrom: noop,\n            isCartesian: false,\n            pointClass: WordcloudPoint,\n            setClip: noop,\n            // Strategies used for deciding rotation and initial position of a word. To\n            // implement a custom strategy, have a look at the function random for\n            // example.\n            placementStrategy: {\n                random: function (point, options) {\n                    const field = options.field, r = options.rotation;\n                    return {\n                        x: getRandomPosition(field.width) - (field.width / 2),\n                        y: getRandomPosition(field.height) - (field.height / 2),\n                        rotation: getRotation(r.orientations, point.index, r.from, r.to)\n                    };\n                },\n                center: function (point, options) {\n                    const r = options.rotation;\n                    return {\n                        x: 0,\n                        y: 0,\n                        rotation: getRotation(r.orientations, point.index, r.from, r.to)\n                    };\n                }\n            },\n            pointArrayMap: ['weight'],\n            // Spirals used for placing a word after the initial position experienced a\n            // collision with either another word or the borders. To implement a custom\n            // spiral, look at the function archimedeanSpiral for example.\n            spirals: {\n                'archimedean': archimedeanSpiral,\n                'rectangular': rectangularSpiral,\n                'square': squareSpiral\n            },\n            utils: {\n                extendPlayingField: extendPlayingField,\n                getRotation: getRotation,\n                isPolygonsColliding: isPolygonsColliding,\n                rotate2DToOrigin: rotate2DToOrigin,\n                rotate2DToPoint: rotate2DToPoint\n            }\n        });\n        SeriesRegistry.registerSeriesType('wordcloud', WordcloudSeries);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return WordcloudSeries;\n    });\n    _registerModule(_modules, 'masters/modules/wordcloud.src.js', [], function () {\n\n\n    });\n}));"],"names":["factory","module","exports","define","amd","Highcharts","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","window","dispatchEvent","detail","U","isNumber","draw","point","params","animatableAttribs","onComplete","css","renderer","animation","series","chart","hasRendered","options","graphic","attribs","getClassName","shouldDraw","shapeType","text","image","imageUrl","attr","shapeArgs","add","group","animate","isNew","destroy","Object","keys","length","SeriesRegistry","column","prototype","pointClass","ColumnPoint","seriesTypes","extend","WordcloudPoint","isValid","weight","allowExtendPlayingField","duration","borderWidth","clip","colorByPoint","cropThreshold","Infinity","minFontSize","maxFontSize","placementStrategy","rotation","from","orientations","to","showInLegend","spiral","style","fontFamily","fontWeight","whiteSpace","tooltip","followPointer","pointFormat","H","deg2rad","find","isObject","merge","isRectanglesIntersecting","r1","r2","left","right","top","bottom","getAxesFromPolygon","polygon","points","axes","concat","reduce","p1","p2","normals","getNormals","dx","dy","axis","existing","push","project","target","products","map","ax","ay","bx","by","min","Math","max","isPolygonsColliding","polygon1","polygon2","axes1","axes2","overlappingOnAllAxes","isPolygonsOverlappingOnAxis","projection1","projection2","isOverlapping","squareSpiral","attempt","a","k","ceil","sqrt","t","m","pow","result","x","y","correctFloat","number","precision","p","magnitude","round","rotate2DToOrigin","angle","rad","cosAngle","cos","sinAngle","sin","rotate2DToPoint","origin","rotated","archimedeanSpiral","field","maxDelta","width","height","abs","extendPlayingField","rectangle","ratioX","ratioY","extendWidth","extendHeight","getBoundingBoxFromPolygon","Number","MAX_VALUE","getPlayingField","targetWidth","targetHeight","data","info","dimensions","maxHeight","maxWidth","area","getPolygon","getRandomPosition","size","random","getRotation","index","intervals","range","orientation","getScale","getSpiral","arr","i","intersectionTesting","placed","rect","delta","intersectsAnyWord","lastCollidedWith","isIntersecting","intersects","outsidePlayingField","playingField","movePolygon","deltaX","deltaY","rectangularSpiral","updateFieldBoundaries","DPU","WordcloudSeriesDefaults","WU","noop","ColumnSeries","isArray","WordcloudSeries","pointAttribs","state","call","stroke","deriveFontSize","relativeWeight","floor","drawPoints","xAxis","yAxis","weights","maxWeight","sort","b","testElement","scaleX","scaleY","fontSize","name","bBox","getBBox","len","spirals","placement","selected","align","isNull","isInside","scale","hasData","visible","getPlotBox","inverted","plotWidth","plotHeight","plotLeft","plotTop","translateX","translateY","defaultOptions","animateDrilldown","animateDrillupFrom","isCartesian","setClip","r","center","pointArrayMap","utils","registerSeriesType"],"mappings":"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"}