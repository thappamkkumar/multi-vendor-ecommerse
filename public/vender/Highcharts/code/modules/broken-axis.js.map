{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts JS v11.3.0 (2024-01-10)\n *\n * (c) 2009-2024 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/broken-axis', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                window.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Core/Axis/BrokenAxis.js', [_modules['Core/Globals.js'], _modules['Core/Axis/Stacking/StackItem.js'], _modules['Core/Utilities.js']], function (H, StackItem, U) {\n        /* *\n         *\n         *  (c) 2009-2024 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { composed } = H;\n        const { addEvent, find, fireEvent, isArray, isNumber, pick, pushUnique } = U;\n        /* *\n         *\n         *  Composition\n         *\n         * */\n        /**\n         * Axis with support of broken data rows.\n         * @private\n         */\n        var BrokenAxis;\n        (function (BrokenAxis) {\n            /* *\n             *\n             *  Declarations\n             *\n             * */\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Adds support for broken axes.\n             * @private\n             */\n            function compose(AxisClass, SeriesClass) {\n                if (pushUnique(composed, compose)) {\n                    AxisClass.keepProps.push('brokenAxis');\n                    addEvent(AxisClass, 'init', onAxisInit);\n                    addEvent(AxisClass, 'afterInit', onAxisAfterInit);\n                    addEvent(AxisClass, 'afterSetTickPositions', onAxisAfterSetTickPositions);\n                    addEvent(AxisClass, 'afterSetOptions', onAxisAfterSetOptions);\n                    const seriesProto = SeriesClass.prototype;\n                    seriesProto.drawBreaks = seriesDrawBreaks;\n                    seriesProto.gappedPath = seriesGappedPath;\n                    addEvent(SeriesClass, 'afterGeneratePoints', onSeriesAfterGeneratePoints);\n                    addEvent(SeriesClass, 'afterRender', onSeriesAfterRender);\n                }\n                return AxisClass;\n            }\n            BrokenAxis.compose = compose;\n            /**\n             * @private\n             */\n            function onAxisAfterInit() {\n                if (typeof this.brokenAxis !== 'undefined') {\n                    this.brokenAxis.setBreaks(this.options.breaks, false);\n                }\n            }\n            /**\n             * Force Axis to be not-ordinal when breaks are defined.\n             * @private\n             */\n            function onAxisAfterSetOptions() {\n                const axis = this;\n                if (axis.brokenAxis?.hasBreaks) {\n                    axis.options.ordinal = false;\n                }\n            }\n            /**\n             * @private\n             */\n            function onAxisAfterSetTickPositions() {\n                const axis = this, brokenAxis = axis.brokenAxis;\n                if (brokenAxis?.hasBreaks) {\n                    const tickPositions = axis.tickPositions, info = axis.tickPositions.info, newPositions = [];\n                    for (let i = 0; i < tickPositions.length; i++) {\n                        if (!brokenAxis.isInAnyBreak(tickPositions[i])) {\n                            newPositions.push(tickPositions[i]);\n                        }\n                    }\n                    axis.tickPositions = newPositions;\n                    axis.tickPositions.info = info;\n                }\n            }\n            /**\n             * @private\n             */\n            function onAxisInit() {\n                const axis = this;\n                if (!axis.brokenAxis) {\n                    axis.brokenAxis = new Additions(axis);\n                }\n            }\n            /**\n             * @private\n             */\n            function onSeriesAfterGeneratePoints() {\n                const { isDirty, options: { connectNulls }, points, xAxis, yAxis } = this;\n                // Set, or reset visibility of the points. Axis.setBreaks marks\n                // the series as isDirty\n                if (isDirty) {\n                    let i = points.length;\n                    while (i--) {\n                        const point = points[i];\n                        // Respect nulls inside the break (#4275)\n                        const nullGap = point.y === null && connectNulls === false;\n                        const isPointInBreak = (!nullGap && (xAxis?.brokenAxis?.isInAnyBreak(point.x, true) ||\n                            yAxis?.brokenAxis?.isInAnyBreak(point.y, true)));\n                        // Set point.visible if in any break.\n                        // If not in break, reset visible to original value.\n                        point.visible = isPointInBreak ?\n                            false :\n                            point.options.visible !== false;\n                    }\n                }\n            }\n            /**\n             * @private\n             */\n            function onSeriesAfterRender() {\n                this.drawBreaks(this.xAxis, ['x']);\n                this.drawBreaks(this.yAxis, pick(this.pointArrayMap, ['y']));\n            }\n            /**\n             * @private\n             */\n            function seriesDrawBreaks(axis, keys) {\n                const series = this, points = series.points;\n                let breaks, threshold, y;\n                if (axis?.brokenAxis?.hasBreaks) {\n                    const brokenAxis = axis.brokenAxis;\n                    keys.forEach(function (key) {\n                        breaks = brokenAxis?.breakArray || [];\n                        threshold = axis.isXAxis ?\n                            axis.min :\n                            pick(series.options.threshold, axis.min);\n                        // Array of breaks that have been \"zoomed-out\" which means that\n                        // they were shown previously, but now after zoom, they are not\n                        // (#19885).\n                        const breaksOutOfRange = axis?.options?.breaks?.filter(function (brk) {\n                            let isOut = true;\n                            // Iterate to see if \"brk\" is in axis range\n                            for (let i = 0; i < breaks.length; i++) {\n                                const otherBreak = breaks[i];\n                                if (otherBreak.from === brk.from &&\n                                    otherBreak.to === brk.to) {\n                                    isOut = false;\n                                    break;\n                                }\n                            }\n                            return isOut;\n                        });\n                        points.forEach(function (point) {\n                            y = pick(point['stack' + key.toUpperCase()], point[key]);\n                            breaks.forEach(function (brk) {\n                                if (isNumber(threshold) && isNumber(y)) {\n                                    let eventName = '';\n                                    if ((threshold < brk.from && y > brk.to) ||\n                                        (threshold > brk.from && y < brk.from)) {\n                                        eventName = 'pointBreak';\n                                    }\n                                    else if ((threshold < brk.from &&\n                                        y > brk.from &&\n                                        y < brk.to) || (threshold > brk.from &&\n                                        y > brk.to &&\n                                        y < brk.from)) {\n                                        eventName = 'pointInBreak';\n                                    }\n                                    if (eventName) {\n                                        fireEvent(axis, eventName, { point, brk });\n                                    }\n                                }\n                            });\n                            breaksOutOfRange?.forEach(function (brk) {\n                                fireEvent(axis, 'pointOutsideOfBreak', { point, brk });\n                            });\n                        });\n                    });\n                }\n            }\n            /**\n             * Extend getGraphPath by identifying gaps in the data so that we\n             * can draw a gap in the line or area. This was moved from ordinal\n             * axis module to broken axis module as of #5045.\n             *\n             * @private\n             * @function Highcharts.Series#gappedPath\n             *\n             * @return {Highcharts.SVGPathArray}\n             * Gapped path\n             */\n            function seriesGappedPath() {\n                const currentDataGrouping = this.currentDataGrouping, groupingSize = currentDataGrouping?.gapSize, points = this.points.slice(), yAxis = this.yAxis;\n                let gapSize = this.options.gapSize, i = points.length - 1, stack;\n                /**\n                 * Defines when to display a gap in the graph, together with the\n                 * [gapUnit](plotOptions.series.gapUnit) option.\n                 *\n                 * In case when `dataGrouping` is enabled, points can be grouped\n                 * into a larger time span. This can make the grouped points to\n                 * have a greater distance than the absolute value of `gapSize`\n                 * property, which will result in disappearing graph completely.\n                 * To prevent this situation the mentioned distance between\n                 * grouped points is used instead of previously defined\n                 * `gapSize`.\n                 *\n                 * In practice, this option is most often used to visualize gaps\n                 * in time series. In a stock chart, intraday data is available\n                 * for daytime hours, while gaps will appear in nights and\n                 * weekends.\n                 *\n                 * @see [gapUnit](plotOptions.series.gapUnit)\n                 * @see [xAxis.breaks](#xAxis.breaks)\n                 *\n                 * @sample {highstock} stock/plotoptions/series-gapsize/\n                 * Setting the gap size to 2 introduces gaps for weekends in\n                 * daily datasets.\n                 *\n                 * @type      {number}\n                 * @default   0\n                 * @product   highstock\n                 * @requires  modules/broken-axis\n                 * @apioption plotOptions.series.gapSize\n                 */\n                /**\n                 * Together with [gapSize](plotOptions.series.gapSize), this\n                 * option defines where to draw gaps in the graph.\n                 *\n                 * When the `gapUnit` is `\"relative\"` (default), a gap size of 5\n                 * means that if the distance between two points is greater than\n                 * 5 times that of the two closest points, the graph will be\n                 * broken.\n                 *\n                 * When the `gapUnit` is `\"value\"`, the gap is based on absolute\n                 * axis values, which on a datetime axis is milliseconds. This\n                 * also applies to the navigator series that inherits gap\n                 * options from the base series.\n                 *\n                 * @see [gapSize](plotOptions.series.gapSize)\n                 *\n                 * @type       {string}\n                 * @default    relative\n                 * @since      5.0.13\n                 * @product    highstock\n                 * @validvalue [\"relative\", \"value\"]\n                 * @requires   modules/broken-axis\n                 * @apioption  plotOptions.series.gapUnit\n                 */\n                if (gapSize && i > 0) { // #5008\n                    // Gap unit is relative\n                    if (this.options.gapUnit !== 'value') {\n                        gapSize *= this.basePointRange;\n                    }\n                    // Setting a new gapSize in case dataGrouping is enabled\n                    // (#7686)\n                    if (groupingSize &&\n                        groupingSize > gapSize &&\n                        // Except when DG is forced (e.g. from other series)\n                        // and has lower granularity than actual points (#11351)\n                        groupingSize >= this.basePointRange) {\n                        gapSize = groupingSize;\n                    }\n                    // extension for ordinal breaks\n                    let current, next;\n                    while (i--) {\n                        // Reassign next if it is not visible\n                        if (!(next && next.visible !== false)) {\n                            next = points[i + 1];\n                        }\n                        current = points[i];\n                        // Skip iteration if one of the points is not visible\n                        if (next.visible === false || current.visible === false) {\n                            continue;\n                        }\n                        if (next.x - current.x > gapSize) {\n                            const xRange = (current.x + next.x) / 2;\n                            points.splice(// insert after this one\n                            i + 1, 0, {\n                                isNull: true,\n                                x: xRange\n                            });\n                            // For stacked chart generate empty stack items, #6546\n                            if (yAxis.stacking && this.options.stacking) {\n                                stack = yAxis.stacking.stacks[this.stackKey][xRange] = new StackItem(yAxis, yAxis.options.stackLabels, false, xRange, this.stack);\n                                stack.total = 0;\n                            }\n                        }\n                        // Assign current to next for the upcoming iteration\n                        next = current;\n                    }\n                }\n                // Call base method\n                return this.getGraphPath(points);\n            }\n            /* *\n             *\n             *  Class\n             *\n             * */\n            /**\n             * Provides support for broken axes.\n             * @private\n             * @class\n             */\n            class Additions {\n                /* *\n                 *\n                 *  Static Functions\n                 *\n                 * */\n                /**\n                 * @private\n                 */\n                static isInBreak(brk, val) {\n                    const repeat = brk.repeat || Infinity, from = brk.from, length = brk.to - brk.from, test = (val >= from ?\n                        (val - from) % repeat :\n                        repeat - ((from - val) % repeat));\n                    let ret;\n                    if (!brk.inclusive) {\n                        ret = test < length && test !== 0;\n                    }\n                    else {\n                        ret = test <= length;\n                    }\n                    return ret;\n                }\n                /**\n                 * @private\n                 */\n                static lin2Val(val) {\n                    const axis = this;\n                    const brokenAxis = axis.brokenAxis;\n                    const breakArray = brokenAxis && brokenAxis.breakArray;\n                    if (!breakArray || !isNumber(val)) {\n                        return val;\n                    }\n                    let nval = val, brk, i;\n                    for (i = 0; i < breakArray.length; i++) {\n                        brk = breakArray[i];\n                        if (brk.from >= nval) {\n                            break;\n                        }\n                        else if (brk.to < nval) {\n                            nval += brk.len;\n                        }\n                        else if (Additions.isInBreak(brk, nval)) {\n                            nval += brk.len;\n                        }\n                    }\n                    return nval;\n                }\n                /**\n                 * @private\n                 */\n                static val2Lin(val) {\n                    const axis = this;\n                    const brokenAxis = axis.brokenAxis;\n                    const breakArray = brokenAxis && brokenAxis.breakArray;\n                    if (!breakArray || !isNumber(val)) {\n                        return val;\n                    }\n                    let nval = val, brk, i;\n                    for (i = 0; i < breakArray.length; i++) {\n                        brk = breakArray[i];\n                        if (brk.to <= val) {\n                            nval -= brk.len;\n                        }\n                        else if (brk.from >= val) {\n                            break;\n                        }\n                        else if (Additions.isInBreak(brk, val)) {\n                            nval -= (val - brk.from);\n                            break;\n                        }\n                    }\n                    return nval;\n                }\n                /* *\n                 *\n                 *  Constructors\n                 *\n                 * */\n                constructor(axis) {\n                    this.hasBreaks = false;\n                    this.axis = axis;\n                }\n                /* *\n                 *\n                 *  Functions\n                 *\n                 * */\n                /**\n                 * Returns the first break found where the x is larger then break.from\n                 * and smaller then break.to.\n                 *\n                 * @param {number} x\n                 * The number which should be within a break.\n                 *\n                 * @param {Array<Highcharts.XAxisBreaksOptions>} breaks\n                 * The array of breaks to search within.\n                 *\n                 * @return {Highcharts.XAxisBreaksOptions|undefined}\n                 * Returns the first break found that matches, returns false if no break\n                 * is found.\n                 */\n                findBreakAt(x, breaks) {\n                    return find(breaks, function (b) {\n                        return b.from < x && x < b.to;\n                    });\n                }\n                /**\n                 * @private\n                 */\n                isInAnyBreak(val, testKeep) {\n                    const brokenAxis = this, axis = brokenAxis.axis, breaks = axis.options.breaks || [];\n                    let i = breaks.length, inbrk, keep, ret;\n                    if (i && isNumber(val)) {\n                        while (i--) {\n                            if (Additions.isInBreak(breaks[i], val)) {\n                                inbrk = true;\n                                if (!keep) {\n                                    keep = pick(breaks[i].showPoints, !axis.isXAxis);\n                                }\n                            }\n                        }\n                        if (inbrk && testKeep) {\n                            ret = inbrk && !keep;\n                        }\n                        else {\n                            ret = inbrk;\n                        }\n                    }\n                    return ret;\n                }\n                /**\n                 * Dynamically set or unset breaks in an axis. This function in lighter\n                 * than usin Axis.update, and it also preserves animation.\n                 *\n                 * @private\n                 * @function Highcharts.Axis#setBreaks\n                 *\n                 * @param {Array<Highcharts.XAxisBreaksOptions>} [breaks]\n                 * The breaks to add. When `undefined` it removes existing breaks.\n                 *\n                 * @param {boolean} [redraw=true]\n                 * Whether to redraw the chart immediately.\n                 */\n                setBreaks(breaks, redraw) {\n                    const brokenAxis = this;\n                    const axis = brokenAxis.axis;\n                    const hasBreaks = isArray(breaks) &&\n                        !!breaks.length &&\n                        !!Object.keys(breaks[0]).length; // Check for [{}], #16368.\n                    axis.isDirty = brokenAxis.hasBreaks !== hasBreaks;\n                    brokenAxis.hasBreaks = hasBreaks;\n                    if (breaks !== axis.options.breaks) {\n                        axis.options.breaks = axis.userOptions.breaks = breaks;\n                    }\n                    axis.forceRedraw = true; // Force recalculation in setScale\n                    // Recalculate series related to the axis.\n                    axis.series.forEach(function (series) {\n                        series.isDirty = true;\n                    });\n                    if (!hasBreaks && axis.val2lin === Additions.val2Lin) {\n                        // Revert to prototype functions\n                        delete axis.val2lin;\n                        delete axis.lin2val;\n                    }\n                    if (hasBreaks) {\n                        axis.userOptions.ordinal = false;\n                        axis.lin2val = Additions.lin2Val;\n                        axis.val2lin = Additions.val2Lin;\n                        axis.setExtremes = function (newMin, newMax, redraw, animation, eventArguments) {\n                            // If trying to set extremes inside a break, extend min to\n                            // after, and max to before the break ( #3857 )\n                            if (brokenAxis.hasBreaks) {\n                                const breaks = (this.options.breaks || []);\n                                let axisBreak;\n                                while ((axisBreak = brokenAxis.findBreakAt(newMin, breaks))) {\n                                    newMin = axisBreak.to;\n                                }\n                                while ((axisBreak = brokenAxis.findBreakAt(newMax, breaks))) {\n                                    newMax = axisBreak.from;\n                                }\n                                // If both min and max is within the same break.\n                                if (newMax < newMin) {\n                                    newMax = newMin;\n                                }\n                            }\n                            axis.constructor.prototype.setExtremes.call(this, newMin, newMax, redraw, animation, eventArguments);\n                        };\n                        axis.setAxisTranslation = function () {\n                            axis.constructor.prototype.setAxisTranslation.call(this);\n                            brokenAxis.unitLength = void 0;\n                            if (brokenAxis.hasBreaks) {\n                                const breaks = axis.options.breaks || [], \n                                // Temporary one:\n                                breakArrayT = [], breakArray = [], pointRangePadding = pick(axis.pointRangePadding, 0);\n                                let length = 0, inBrk, repeat, min = axis.userMin || axis.min, max = axis.userMax || axis.max, start, i;\n                                // Min & max check (#4247)\n                                breaks.forEach(function (brk) {\n                                    repeat = brk.repeat || Infinity;\n                                    if (isNumber(min) && isNumber(max)) {\n                                        if (Additions.isInBreak(brk, min)) {\n                                            min += ((brk.to % repeat) -\n                                                (min % repeat));\n                                        }\n                                        if (Additions.isInBreak(brk, max)) {\n                                            max -= ((max % repeat) -\n                                                (brk.from % repeat));\n                                        }\n                                    }\n                                });\n                                // Construct an array holding all breaks in the axis\n                                breaks.forEach(function (brk) {\n                                    start = brk.from;\n                                    repeat = brk.repeat || Infinity;\n                                    if (isNumber(min) && isNumber(max)) {\n                                        while (start - repeat > min) {\n                                            start -= repeat;\n                                        }\n                                        while (start < min) {\n                                            start += repeat;\n                                        }\n                                        for (i = start; i < max; i += repeat) {\n                                            breakArrayT.push({\n                                                value: i,\n                                                move: 'in'\n                                            });\n                                            breakArrayT.push({\n                                                value: i + brk.to - brk.from,\n                                                move: 'out',\n                                                size: brk.breakSize\n                                            });\n                                        }\n                                    }\n                                });\n                                breakArrayT.sort(function (a, b) {\n                                    return ((a.value === b.value) ?\n                                        ((a.move === 'in' ? 0 : 1) -\n                                            (b.move === 'in' ? 0 : 1)) :\n                                        a.value - b.value);\n                                });\n                                // Simplify the breaks\n                                inBrk = 0;\n                                start = min;\n                                breakArrayT.forEach(function (brk) {\n                                    inBrk += (brk.move === 'in' ? 1 : -1);\n                                    if (inBrk === 1 && brk.move === 'in') {\n                                        start = brk.value;\n                                    }\n                                    if (inBrk === 0 && isNumber(start)) {\n                                        breakArray.push({\n                                            from: start,\n                                            to: brk.value,\n                                            len: brk.value - start - (brk.size || 0)\n                                        });\n                                        length += (brk.value -\n                                            start -\n                                            (brk.size || 0));\n                                    }\n                                });\n                                brokenAxis.breakArray = breakArray;\n                                // Used with staticScale, and below the actual axis\n                                // length, when breaks are substracted.\n                                if (isNumber(min) &&\n                                    isNumber(max) &&\n                                    isNumber(axis.min)) {\n                                    brokenAxis.unitLength = max - min - length +\n                                        pointRangePadding;\n                                    fireEvent(axis, 'afterBreaks');\n                                    if (axis.staticScale) {\n                                        axis.transA = axis.staticScale;\n                                    }\n                                    else if (brokenAxis.unitLength) {\n                                        axis.transA *=\n                                            (max - axis.min + pointRangePadding) /\n                                                brokenAxis.unitLength;\n                                    }\n                                    if (pointRangePadding) {\n                                        axis.minPixelPadding =\n                                            axis.transA * (axis.minPointOffset || 0);\n                                    }\n                                    axis.min = min;\n                                    axis.max = max;\n                                }\n                            }\n                        };\n                    }\n                    if (pick(redraw, true)) {\n                        axis.chart.redraw();\n                    }\n                }\n            }\n            BrokenAxis.Additions = Additions;\n        })(BrokenAxis || (BrokenAxis = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return BrokenAxis;\n    });\n    _registerModule(_modules, 'masters/modules/broken-axis.src.js', [_modules['Core/Globals.js'], _modules['Core/Axis/BrokenAxis.js']], function (Highcharts, BrokenAxis) {\n\n        const G = Highcharts;\n        // Compositions\n        BrokenAxis.compose(G.Axis, G.Series);\n\n    });\n}));"],"names":["factory","module","exports","define","amd","Highcharts","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","window","dispatchEvent","detail","H","StackItem","U","BrokenAxis","composed","addEvent","find","fireEvent","isArray","isNumber","pick","pushUnique","onAxisAfterInit","brokenAxis","setBreaks","options","breaks","onAxisAfterSetOptions","axis","hasBreaks","ordinal","onAxisAfterSetTickPositions","tickPositions","info","newPositions","i","length","isInAnyBreak","push","onAxisInit","Additions","onSeriesAfterGeneratePoints","isDirty","connectNulls","points","xAxis","yAxis","point","nullGap","y","isPointInBreak","x","visible","onSeriesAfterRender","drawBreaks","pointArrayMap","seriesDrawBreaks","keys","threshold","series","forEach","key","breakArray","isXAxis","min","breaksOutOfRange","filter","brk","isOut","otherBreak","from","to","toUpperCase","eventName","seriesGappedPath","currentDataGrouping","groupingSize","gapSize","slice","current","next","gapUnit","basePointRange","xRange","splice","isNull","stacking","stack","stacks","stackKey","stackLabels","total","getGraphPath","compose","AxisClass","SeriesClass","keepProps","seriesProto","prototype","gappedPath","isInBreak","val","repeat","Infinity","test","inclusive","lin2Val","nval","len","val2Lin","constructor","findBreakAt","b","testKeep","inbrk","keep","ret","showPoints","redraw","Object","userOptions","forceRedraw","val2lin","lin2val","setExtremes","newMin","newMax","animation","eventArguments","axisBreak","call","setAxisTranslation","unitLength","breakArrayT","pointRangePadding","inBrk","userMin","max","userMax","start","value","move","size","breakSize","sort","a","staticScale","transA","minPixelPadding","minPointOffset","chart","G","Axis","Series"],"mappings":"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"}