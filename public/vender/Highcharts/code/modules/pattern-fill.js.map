{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts JS v11.3.0 (2024-01-10)\n *\n * Module for adding patterns and images as point fills.\n *\n * (c) 2010-2024 Highsoft AS\n * Author: Torstein Hønsi, Øystein Moseng\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/pattern-fill', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                window.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Extensions/PatternFill.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Defaults.js'], _modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (A, D, H, U) {\n        /* *\n         *\n         *  Module for using patterns or images as point fills.\n         *\n         *  (c) 2010-2024 Highsoft AS\n         *  Author: Torstein Hønsi, Øystein Moseng\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { animObject } = A;\n        const { getOptions } = D;\n        const { composed } = H;\n        const { addEvent, defined, erase, extend, merge, pick, pushUnique, removeEvent, wrap } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const patterns = createPatterns();\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /** @private */\n        function compose(ChartClass, SeriesClass, SVGRendererClass) {\n            const PointClass = SeriesClass.prototype.pointClass;\n            if (pushUnique(composed, compose)) {\n                addEvent(ChartClass, 'endResize', onChartEndResize);\n                addEvent(ChartClass, 'redraw', onChartRedraw);\n                extend(PointClass.prototype, {\n                    calculatePatternDimensions: pointCalculatePatternDimensions\n                });\n                addEvent(PointClass, 'afterInit', onPointAfterInit);\n                addEvent(SeriesClass, 'render', onSeriesRender);\n                wrap(SeriesClass.prototype, 'getColor', wrapSeriesGetColor);\n                // Pattern scale corrections\n                addEvent(SeriesClass, 'afterRender', onPatternScaleCorrection);\n                addEvent(SeriesClass, 'mapZoomComplete', onPatternScaleCorrection);\n                extend(SVGRendererClass.prototype, {\n                    addPattern: rendererAddPattern\n                });\n                addEvent(SVGRendererClass, 'complexColor', onRendererComplexColor);\n            }\n        }\n        /**\n         * Add the predefined patterns.\n         * @private\n         */\n        function createPatterns() {\n            const patterns = [], colors = getOptions().colors;\n            // Start with subtle patterns\n            let i = 0;\n            for (const pattern of [\n                'M 0 0 L 5 5 M 4.5 -0.5 L 5.5 0.5 M -0.5 4.5 L 0.5 5.5',\n                'M 0 5 L 5 0 M -0.5 0.5 L 0.5 -0.5 M 4.5 5.5 L 5.5 4.5',\n                'M 2 0 L 2 5 M 4 0 L 4 5',\n                'M 0 2 L 5 2 M 0 4 L 5 4',\n                'M 0 1.5 L 2.5 1.5 L 2.5 0 M 2.5 5 L 2.5 3.5 L 5 3.5'\n            ]) {\n                patterns.push({\n                    path: pattern,\n                    color: colors[i++],\n                    width: 5,\n                    height: 5,\n                    patternTransform: 'scale(1.4 1.4)'\n                });\n            }\n            // Then add the more drastic ones\n            i = 5;\n            for (const pattern of [\n                'M 0 0 L 5 10 L 10 0',\n                'M 3 3 L 8 3 L 8 8 L 3 8 Z',\n                'M 5 5 m -4 0 a 4 4 0 1 1 8 0 a 4 4 0 1 1 -8 0',\n                'M 0 0 L 10 10 M 9 -1 L 11 1 M -1 9 L 1 11',\n                'M 0 10 L 10 0 M -1 1 L 1 -1 M 9 11 L 11 9'\n            ]) {\n                patterns.push({\n                    path: pattern,\n                    color: colors[i],\n                    width: 10,\n                    height: 10\n                });\n                i = i + 5;\n            }\n            return patterns;\n        }\n        /**\n         * Utility function to compute a hash value from an object. Modified Java\n         * String.hashCode implementation in JS. Use the preSeed parameter to add an\n         * additional seeding step.\n         *\n         * @private\n         * @function hashFromObject\n         *\n         * @param {Object} obj\n         *        The javascript object to compute the hash from.\n         *\n         * @param {boolean} [preSeed=false]\n         *        Add an optional preSeed stage.\n         *\n         * @return {string}\n         *         The computed hash.\n         */\n        function hashFromObject(obj, preSeed) {\n            const str = JSON.stringify(obj), strLen = str.length || 0;\n            let hash = 0, i = 0, char, seedStep;\n            if (preSeed) {\n                seedStep = Math.max(Math.floor(strLen / 500), 1);\n                for (let a = 0; a < strLen; a += seedStep) {\n                    hash += str.charCodeAt(a);\n                }\n                hash = hash & hash;\n            }\n            for (; i < strLen; ++i) {\n                char = str.charCodeAt(i);\n                hash = ((hash << 5) - hash) + char;\n                hash = hash & hash;\n            }\n            return hash.toString(16).replace('-', '1');\n        }\n        /**\n         * When animation is used, we have to recalculate pattern dimensions after\n         * resize, as the bounding boxes are not available until then.\n         * @private\n         */\n        function onChartEndResize() {\n            if (this.renderer &&\n                (this.renderer.defIds || []).filter((id) => (id &&\n                    id.indexOf &&\n                    id.indexOf('highcharts-pattern-') === 0)).length) {\n                // We have non-default patterns to fix. Find them by looping through\n                // all points.\n                for (const series of this.series) {\n                    if (series.visible) {\n                        for (const point of series.points) {\n                            const colorOptions = point.options && point.options.color;\n                            if (colorOptions &&\n                                colorOptions.pattern) {\n                                colorOptions.pattern\n                                    ._width = 'defer';\n                                colorOptions.pattern\n                                    ._height = 'defer';\n                            }\n                        }\n                    }\n                }\n                // Redraw without animation\n                this.redraw(false);\n            }\n        }\n        /**\n         * Add a garbage collector to delete old patterns with autogenerated hashes that\n         * are no longer being referenced.\n         * @private\n         */\n        function onChartRedraw() {\n            const usedIds = {}, renderer = this.renderer, \n            // Get the autocomputed patterns - these are the ones we might delete\n            patterns = (renderer.defIds || []).filter((pattern) => (pattern.indexOf &&\n                pattern.indexOf('highcharts-pattern-') === 0));\n            if (patterns.length) {\n                // Look through the DOM for usage of the patterns. This can be points,\n                // series, tooltips etc.\n                [].forEach.call(this.renderTo.querySelectorAll('[color^=\"url(\"], [fill^=\"url(\"], [stroke^=\"url(\"]'), (node) => {\n                    const id = node.getAttribute('fill') ||\n                        node.getAttribute('color') ||\n                        node.getAttribute('stroke');\n                    if (id) {\n                        const sanitizedId = id\n                            .replace(renderer.url, '')\n                            .replace('url(#', '')\n                            .replace(')', '');\n                        usedIds[sanitizedId] = true;\n                    }\n                });\n                // Loop through the patterns that exist and see if they are used\n                for (const id of patterns) {\n                    if (!usedIds[id]) {\n                        // Remove id from used id list\n                        erase(renderer.defIds, id);\n                        // Remove pattern element\n                        if (renderer.patternElements[id]) {\n                            renderer.patternElements[id].destroy();\n                            delete renderer.patternElements[id];\n                        }\n                    }\n                }\n            }\n        }\n        /**\n         * Merge series color options to points.\n         * @private\n         */\n        function onPointAfterInit() {\n            const point = this, colorOptions = point.options.color;\n            // Only do this if we have defined a specific color on this point. Otherwise\n            // we will end up trying to re-add the series color for each point.\n            if (colorOptions && colorOptions.pattern) {\n                // Move path definition to object, allows for merge with series path\n                // definition\n                if (typeof colorOptions.pattern.path === 'string') {\n                    colorOptions.pattern.path = {\n                        d: colorOptions.pattern.path\n                    };\n                }\n                // Merge with series options\n                point.color = point.options.color = merge(point.series.options.color, colorOptions);\n            }\n        }\n        /**\n         * Add functionality to SVG renderer to handle patterns as complex colors.\n         * @private\n         */\n        function onRendererComplexColor(args) {\n            const color = args.args[0], prop = args.args[1], element = args.args[2], chartIndex = (this.chartIndex || 0);\n            let pattern = color.pattern, value = \"#333333\" /* Palette.neutralColor80 */;\n            // Handle patternIndex\n            if (typeof color.patternIndex !== 'undefined' && patterns) {\n                pattern = patterns[color.patternIndex];\n            }\n            // Skip and call default if there is no pattern\n            if (!pattern) {\n                return true;\n            }\n            // We have a pattern.\n            if (pattern.image ||\n                typeof pattern.path === 'string' ||\n                pattern.path && pattern.path.d) {\n                // Real pattern. Add it and set the color value to be a reference.\n                // Force Hash-based IDs for legend items, as they are drawn before\n                // point render, meaning they are drawn before autocalculated image\n                // width/heights. We don't want them to highjack the width/height for\n                // this ID if it is defined by users.\n                let forceHashId = element.parentNode &&\n                    element.parentNode.getAttribute('class');\n                forceHashId = forceHashId &&\n                    forceHashId.indexOf('highcharts-legend') > -1;\n                // If we don't have a width/height yet, handle it. Try faking a point\n                // and running the algorithm again.\n                if (pattern._width === 'defer' || pattern._height === 'defer') {\n                    pointCalculatePatternDimensions.call({ graphic: { element: element } }, pattern);\n                }\n                // If we don't have an explicit ID, compute a hash from the\n                // definition and use that as the ID. This ensures that points with\n                // the same pattern definition reuse existing pattern elements by\n                // default. We combine two hashes, the second with an additional\n                // preSeed algorithm, to minimize collision probability.\n                if (forceHashId || !pattern.id) {\n                    // Make a copy so we don't accidentally edit options when setting ID\n                    pattern = merge({}, pattern);\n                    pattern.id = 'highcharts-pattern-' + chartIndex + '-' +\n                        hashFromObject(pattern) + hashFromObject(pattern, true);\n                }\n                // Add it. This function does nothing if an element with this ID\n                // already exists.\n                this.addPattern(pattern, !this.forExport && pick(pattern.animation, this.globalAnimation, { duration: 100 }));\n                value = `url(${this.url}#${pattern.id + (this.forExport ? '-export' : '')})`;\n            }\n            else {\n                // Not a full pattern definition, just add color\n                value = pattern.color || value;\n            }\n            // Set the fill/stroke prop on the element\n            element.setAttribute(prop, value);\n            // Allow the color to be concatenated into tooltips formatters etc.\n            color.toString = function () {\n                return value;\n            };\n            // Skip default handler\n            return false;\n        }\n        /**\n         * Calculate pattern dimensions on points that have their own pattern.\n         * @private\n         */\n        function onSeriesRender() {\n            const isResizing = this.chart.isResizing;\n            if (this.isDirtyData || isResizing || !this.chart.hasRendered) {\n                for (const point of this.points) {\n                    const colorOptions = point.options && point.options.color;\n                    if (colorOptions &&\n                        colorOptions.pattern) {\n                        // For most points we want to recalculate the dimensions on\n                        // render, where we have the shape args and bbox. But if we\n                        // are resizing and don't have the shape args, defer it, since\n                        // the bounding box is still not resized.\n                        if (isResizing &&\n                            !(point.shapeArgs &&\n                                point.shapeArgs.width &&\n                                point.shapeArgs.height)) {\n                            colorOptions\n                                .pattern._width = 'defer';\n                            colorOptions\n                                .pattern._height = 'defer';\n                        }\n                        else {\n                            point.calculatePatternDimensions(colorOptions.pattern);\n                        }\n                    }\n                }\n            }\n        }\n        /**\n         * Set dimensions on pattern from point. This function will set internal\n         * pattern._width/_height properties if width and height are not both already\n         * set. We only do this on image patterns. The _width/_height properties are set\n         * to the size of the bounding box of the point, optionally taking aspect ratio\n         * into account. If only one of width or height are supplied as options, the\n         * undefined option is calculated as above.\n         *\n         * @private\n         * @function Highcharts.Point#calculatePatternDimensions\n         *\n         * @param {Highcharts.PatternOptionsObject} pattern\n         *        The pattern to set dimensions on.\n         *\n         * @return {void}\n         *\n         * @requires modules/pattern-fill\n         */\n        function pointCalculatePatternDimensions(pattern) {\n            if (pattern.width && pattern.height) {\n                return;\n            }\n            const bBox = this.graphic && (this.graphic.getBBox &&\n                this.graphic.getBBox(true) ||\n                this.graphic.element &&\n                    this.graphic.element.getBBox()) || {}, shapeArgs = this.shapeArgs;\n            // Prefer using shapeArgs, as it is animation agnostic\n            if (shapeArgs) {\n                bBox.width = shapeArgs.width || bBox.width;\n                bBox.height = shapeArgs.height || bBox.height;\n                bBox.x = shapeArgs.x || bBox.x;\n                bBox.y = shapeArgs.y || bBox.y;\n            }\n            // For images we stretch to bounding box\n            if (pattern.image) {\n                // If we do not have a bounding box at this point, simply add a defer\n                // key and pick this up in the fillSetter handler, where the bounding\n                // box should exist.\n                if (!bBox.width || !bBox.height) {\n                    pattern._width = 'defer';\n                    pattern._height = 'defer';\n                    // Mark the pattern to be flipped later if upside down (#16810)\n                    const scaleY = this.series.chart.mapView &&\n                        this.series.chart.mapView.getSVGTransform().scaleY;\n                    if (defined(scaleY) && scaleY < 0) {\n                        pattern._inverted = true;\n                    }\n                    return;\n                }\n                // Handle aspect ratio filling\n                if (pattern.aspectRatio) {\n                    bBox.aspectRatio = bBox.width / bBox.height;\n                    if (pattern.aspectRatio > bBox.aspectRatio) {\n                        // Height of bBox will determine width\n                        bBox.aspectWidth = bBox.height * pattern.aspectRatio;\n                    }\n                    else {\n                        // Width of bBox will determine height\n                        bBox.aspectHeight = bBox.width / pattern.aspectRatio;\n                    }\n                }\n                // We set the width/height on internal properties to differentiate\n                // between the options set by a user and by this function.\n                pattern._width = pattern.width ||\n                    Math.ceil(bBox.aspectWidth || bBox.width);\n                pattern._height = pattern.height ||\n                    Math.ceil(bBox.aspectHeight || bBox.height);\n            }\n            // Set x/y accordingly, centering if using aspect ratio, otherwise adjusting\n            // so bounding box corner is 0,0 of pattern.\n            if (!pattern.width) {\n                pattern._x = pattern.x || 0;\n                pattern._x += bBox.x - Math.round(bBox.aspectWidth ?\n                    Math.abs(bBox.aspectWidth - bBox.width) / 2 :\n                    0);\n            }\n            if (!pattern.height) {\n                pattern._y = pattern.y || 0;\n                pattern._y += bBox.y - Math.round(bBox.aspectHeight ?\n                    Math.abs(bBox.aspectHeight - bBox.height) / 2 :\n                    0);\n            }\n        }\n        /**\n         * Add a pattern to the renderer.\n         *\n         * @private\n         * @function Highcharts.SVGRenderer#addPattern\n         *\n         * @param {Highcharts.PatternObject} options\n         * The pattern options.\n         *\n         * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]\n         * The animation options.\n         *\n         * @return {Highcharts.SVGElement|undefined}\n         * The added pattern. Undefined if the pattern already exists.\n         *\n         * @requires modules/pattern-fill\n         */\n        function rendererAddPattern(options, animation) {\n            const animate = pick(animation, true), animationOptions = animObject(animate), color = options.color || \"#333333\" /* Palette.neutralColor80 */, defaultSize = 32, height = options.height ||\n                (typeof options._height === 'number' ? options._height : 0) ||\n                defaultSize, rect = (fill) => this\n                .rect(0, 0, width, height)\n                .attr({ fill })\n                .add(pattern), width = options.width ||\n                (typeof options._width === 'number' ? options._width : 0) ||\n                defaultSize;\n            let attribs, id = options.id, path;\n            if (!id) {\n                this.idCounter = this.idCounter || 0;\n                id = ('highcharts-pattern-' +\n                    this.idCounter +\n                    '-' +\n                    (this.chartIndex || 0));\n                ++this.idCounter;\n            }\n            if (this.forExport) {\n                id += '-export';\n            }\n            // Do nothing if ID already exists\n            this.defIds = this.defIds || [];\n            if (this.defIds.indexOf(id) > -1) {\n                return;\n            }\n            // Store ID in list to avoid duplicates\n            this.defIds.push(id);\n            // Calculate pattern element attributes\n            const attrs = {\n                id: id,\n                patternUnits: 'userSpaceOnUse',\n                patternContentUnits: options.patternContentUnits || 'userSpaceOnUse',\n                width: width,\n                height: height,\n                x: options._x || options.x || 0,\n                y: options._y || options.y || 0\n            };\n            if (options._inverted) {\n                attrs.patternTransform = 'scale(1, -1)'; // (#16810)\n                if (options.patternTransform) {\n                    options.patternTransform += ' scale(1, -1)';\n                }\n            }\n            if (options.patternTransform) {\n                attrs.patternTransform = options.patternTransform;\n            }\n            const pattern = this.createElement('pattern').attr(attrs).add(this.defs);\n            // Set id on the SVGRenderer object\n            pattern.id = id;\n            // Use an SVG path for the pattern\n            if (options.path) {\n                path = U.isObject(options.path) ?\n                    options.path :\n                    { d: options.path };\n                // The background\n                if (options.backgroundColor) {\n                    rect(options.backgroundColor);\n                }\n                // The pattern\n                attribs = {\n                    'd': path.d\n                };\n                if (!this.styledMode) {\n                    attribs.stroke = path.stroke || color;\n                    attribs['stroke-width'] = pick(path.strokeWidth, 2);\n                    attribs.fill = path.fill || 'none';\n                }\n                if (path.transform) {\n                    attribs.transform = path.transform;\n                }\n                this.createElement('path').attr(attribs).add(pattern);\n                pattern.color = color;\n                // Image pattern\n            }\n            else if (options.image) {\n                if (animate) {\n                    this.image(options.image, 0, 0, width, height, function () {\n                        // Onload\n                        this.animate({\n                            opacity: pick(options.opacity, 1)\n                        }, animationOptions);\n                        removeEvent(this.element, 'load');\n                    }).attr({ opacity: 0 }).add(pattern);\n                }\n                else {\n                    this.image(options.image, 0, 0, width, height).add(pattern);\n                }\n            }\n            // For non-animated patterns, set opacity now\n            if (!(options.image && animate) && typeof options.opacity !== 'undefined') {\n                [].forEach.call(pattern.element.childNodes, (child) => {\n                    child.setAttribute('opacity', options.opacity);\n                });\n            }\n            // Store for future reference\n            this.patternElements = this.patternElements || {};\n            this.patternElements[id] = pattern;\n            return pattern;\n        }\n        /**\n         * Make sure we have a series color.\n         * @private\n         */\n        function wrapSeriesGetColor(proceed) {\n            const oldColor = this.options.color;\n            // Temporarely remove color options to get defaults\n            if (oldColor &&\n                oldColor.pattern &&\n                !oldColor.pattern.color) {\n                delete this.options.color;\n                // Get default\n                proceed.apply(this, [].slice.call(arguments, 1));\n                // Replace with old, but add default color\n                oldColor.pattern.color =\n                    this.color;\n                this.color = this.options.color = oldColor;\n            }\n            else {\n                // We have a color, no need to do anything special\n                proceed.apply(this, [].slice.call(arguments, 1));\n            }\n        }\n        /**\n         * Scale patterns inversly to the series it's used in.\n         * Maintains a visual (1,1) scale regardless of size.\n         * @private\n         */\n        function onPatternScaleCorrection() {\n            const series = this;\n            // If not a series used in a map chart, skip it.\n            if (!series.chart?.mapView) {\n                return;\n            }\n            const chart = series.chart, renderer = chart.renderer, patterns = renderer.patternElements;\n            // Only scale if we have patterns to scale.\n            if (renderer.defIds?.length && patterns) {\n                // Filter for points which have patterns that don't use images assigned\n                // and has a group scale available.\n                series.points.filter(function (p) {\n                    const point = p;\n                    // No graphic we can fetch id from, filter out this point.\n                    if (!point.graphic) {\n                        return false;\n                    }\n                    return (point.graphic.element.hasAttribute('fill') ||\n                        point.graphic.element.hasAttribute('color') ||\n                        point.graphic.element.hasAttribute('stroke')) &&\n                        !point.options.color?.pattern?.image &&\n                        !!point.group?.scaleX &&\n                        !!point.group?.scaleY;\n                })\n                    // Map up pattern id's and their scales.\n                    .map(function (p) {\n                    const point = p;\n                    // Parse the id from the graphic element of the point.\n                    const id = (point.graphic?.element.getAttribute('fill') ||\n                        point.graphic?.element.getAttribute('color') ||\n                        point.graphic?.element.getAttribute('stroke') || '')\n                        .replace(renderer.url, '')\n                        .replace('url(#', '')\n                        .replace(')', '');\n                    return [\n                        id,\n                        {\n                            x: point.group?.scaleX || 1,\n                            y: point.group?.scaleY || 1\n                        }\n                    ];\n                })\n                    // Filter out colors and other non-patterns, as well as duplicates.\n                    .filter(function ([id, _], index, arr) {\n                    return id !== '' &&\n                        id.indexOf('highcharts-pattern-') !== -1 &&\n                        !arr.some(function ([otherID, _], otherIndex) {\n                            return otherID === id && otherIndex < index;\n                        });\n                })\n                    .forEach(function ([id, scale]) {\n                    patterns[id].scaleX = 1 / scale.x;\n                    patterns[id].scaleY = 1 / scale.y;\n                    patterns[id].updateTransform('patternTransform');\n                });\n            }\n        }\n        /* *\n         *\n         *  Export\n         *\n         * */\n        const PatternFill = {\n            compose,\n            patterns\n        };\n        /* *\n         *\n         *  API Declarations\n         *\n         * */\n        /**\n         * Pattern options\n         *\n         * @interface Highcharts.PatternOptionsObject\n         */ /**\n        * Background color for the pattern if a `path` is set (not images).\n        * @name Highcharts.PatternOptionsObject#backgroundColor\n        * @type {Highcharts.ColorString|undefined}\n        */ /**\n        * URL to an image to use as the pattern.\n        * @name Highcharts.PatternOptionsObject#image\n        * @type {string|undefined}\n        */ /**\n        * Width of the pattern. For images this is automatically set to the width of\n        * the element bounding box if not supplied. For non-image patterns the default\n        * is 32px. Note that automatic resizing of image patterns to fill a bounding\n        * box dynamically is only supported for patterns with an automatically\n        * calculated ID.\n        * @name Highcharts.PatternOptionsObject#width\n        * @type {number|undefined}\n        */ /**\n        * Analogous to pattern.width.\n        * @name Highcharts.PatternOptionsObject#height\n        * @type {number|undefined}\n        */ /**\n        * For automatically calculated width and height on images, it is possible to\n        * set an aspect ratio. The image will be zoomed to fill the bounding box,\n        * maintaining the aspect ratio defined.\n        * @name Highcharts.PatternOptionsObject#aspectRatio\n        * @type {number|undefined}\n        */ /**\n        * Horizontal offset of the pattern. Defaults to 0.\n        * @name Highcharts.PatternOptionsObject#x\n        * @type {number|undefined}\n        */ /**\n        * Vertical offset of the pattern. Defaults to 0.\n        * @name Highcharts.PatternOptionsObject#y\n        * @type {number|undefined}\n        */ /**\n        * Either an SVG path as string, or an object. As an object, supply the path\n        * string in the `path.d` property. Other supported properties are standard SVG\n        * attributes like `path.stroke` and `path.fill`. If a path is supplied for the\n        * pattern, the `image` property is ignored.\n        * @name Highcharts.PatternOptionsObject#path\n        * @type {string|Highcharts.SVGAttributes|undefined}\n        */ /**\n        * SVG `patternTransform` to apply to the entire pattern.\n        * @name Highcharts.PatternOptionsObject#patternTransform\n        * @type {string|undefined}\n        * @see [patternTransform demo](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/series/pattern-fill-transform)\n        */ /**\n        * Pattern color, used as default path stroke.\n        * @name Highcharts.PatternOptionsObject#color\n        * @type {Highcharts.ColorString|undefined}\n        */ /**\n        * Opacity of the pattern as a float value from 0 to 1.\n        * @name Highcharts.PatternOptionsObject#opacity\n        * @type {number|undefined}\n        */ /**\n        * ID to assign to the pattern. This is automatically computed if not added, and\n        * identical patterns are reused. To refer to an existing pattern for a\n        * Highcharts color, use `color: \"url(#pattern-id)\"`.\n        * @name Highcharts.PatternOptionsObject#id\n        * @type {string|undefined}\n        */\n        /**\n         * Holds a pattern definition.\n         *\n         * @sample highcharts/series/pattern-fill-area/\n         *         Define a custom path pattern\n         * @sample highcharts/series/pattern-fill-pie/\n         *         Default patterns and a custom image pattern\n         * @sample maps/demo/pattern-fill-map/\n         *         Custom images on map\n         *\n         * @example\n         * // Pattern used as a color option\n         * color: {\n         *     pattern: {\n         *            path: {\n         *                 d: 'M 3 3 L 8 3 L 8 8 Z',\n         *                fill: '#102045'\n         *            },\n         *            width: 12,\n         *            height: 12,\n         *            color: '#907000',\n         *            opacity: 0.5\n         *     }\n         * }\n         *\n         * @interface Highcharts.PatternObject\n         */ /**\n        * Pattern options\n        * @name Highcharts.PatternObject#pattern\n        * @type {Highcharts.PatternOptionsObject}\n        */ /**\n        * Animation options for the image pattern loading.\n        * @name Highcharts.PatternObject#animation\n        * @type {boolean|Partial<Highcharts.AnimationOptionsObject>|undefined}\n        */ /**\n        * Optionally an index referencing which pattern to use. Highcharts adds\n        * 10 default patterns to the `Highcharts.patterns` array. Additional\n        * pattern definitions can be pushed to this array if desired. This option\n        * is an index into this array.\n        * @name Highcharts.PatternObject#patternIndex\n        * @type {number|undefined}\n        */\n        ''; // Keeps doclets above in transpiled file\n\n        return PatternFill;\n    });\n    _registerModule(_modules, 'masters/modules/pattern-fill.src.js', [_modules['Core/Globals.js'], _modules['Extensions/PatternFill.js']], function (Highcharts, PatternFill) {\n\n        const G = Highcharts;\n        G.patterns = PatternFill.patterns;\n        PatternFill.compose(G.Chart, G.Series, G.SVGRenderer);\n\n    });\n}));"],"names":["factory","module","exports","define","amd","Highcharts","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","window","dispatchEvent","detail","A","D","H","U","animObject","getOptions","composed","addEvent","defined","erase","extend","merge","pick","pushUnique","removeEvent","wrap","patterns","createPatterns","colors","i","pattern","push","color","width","height","patternTransform","hashFromObject","preSeed","str","JSON","stringify","strLen","length","hash","seedStep","Math","max","floor","a","charCodeAt","toString","replace","onChartEndResize","renderer","defIds","filter","id","indexOf","series","visible","point","points","colorOptions","options","_width","_height","redraw","onChartRedraw","usedIds","forEach","call","renderTo","querySelectorAll","node","getAttribute","sanitizedId","url","patternElements","destroy","onPointAfterInit","d","onRendererComplexColor","prop","element","chartIndex","value","patternIndex","image","forceHashId","parentNode","pointCalculatePatternDimensions","graphic","addPattern","forExport","animation","globalAnimation","duration","setAttribute","onSeriesRender","isResizing","chart","isDirtyData","hasRendered","shapeArgs","calculatePatternDimensions","bBox","getBBox","x","y","scaleY","mapView","getSVGTransform","_inverted","aspectRatio","aspectWidth","aspectHeight","ceil","_x","round","abs","_y","rendererAddPattern","animate","animationOptions","attribs","idCounter","attrs","patternUnits","patternContentUnits","createElement","attr","add","defs","isObject","backgroundColor","fill","rect","styledMode","stroke","strokeWidth","transform","opacity","childNodes","child","wrapSeriesGetColor","proceed","oldColor","slice","arguments","onPatternScaleCorrection","p","hasAttribute","group","scaleX","map","_","index","arr","some","otherID","otherIndex","scale","updateTransform","compose","ChartClass","SeriesClass","SVGRendererClass","PointClass","prototype","pointClass","PatternFill","G","Chart","Series","SVGRenderer"],"mappings":"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"}