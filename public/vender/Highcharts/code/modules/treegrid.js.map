{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts Gantt JS v11.3.0 (2024-01-10)\n *\n * Tree Grid\n *\n * (c) 2016-2024 Jon Arild Nygard\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/treegrid', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                window.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Core/Axis/BrokenAxis.js', [_modules['Core/Globals.js'], _modules['Core/Axis/Stacking/StackItem.js'], _modules['Core/Utilities.js']], function (H, StackItem, U) {\n        /* *\n         *\n         *  (c) 2009-2024 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { composed } = H;\n        const { addEvent, find, fireEvent, isArray, isNumber, pick, pushUnique } = U;\n        /* *\n         *\n         *  Composition\n         *\n         * */\n        /**\n         * Axis with support of broken data rows.\n         * @private\n         */\n        var BrokenAxis;\n        (function (BrokenAxis) {\n            /* *\n             *\n             *  Declarations\n             *\n             * */\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Adds support for broken axes.\n             * @private\n             */\n            function compose(AxisClass, SeriesClass) {\n                if (pushUnique(composed, compose)) {\n                    AxisClass.keepProps.push('brokenAxis');\n                    addEvent(AxisClass, 'init', onAxisInit);\n                    addEvent(AxisClass, 'afterInit', onAxisAfterInit);\n                    addEvent(AxisClass, 'afterSetTickPositions', onAxisAfterSetTickPositions);\n                    addEvent(AxisClass, 'afterSetOptions', onAxisAfterSetOptions);\n                    const seriesProto = SeriesClass.prototype;\n                    seriesProto.drawBreaks = seriesDrawBreaks;\n                    seriesProto.gappedPath = seriesGappedPath;\n                    addEvent(SeriesClass, 'afterGeneratePoints', onSeriesAfterGeneratePoints);\n                    addEvent(SeriesClass, 'afterRender', onSeriesAfterRender);\n                }\n                return AxisClass;\n            }\n            BrokenAxis.compose = compose;\n            /**\n             * @private\n             */\n            function onAxisAfterInit() {\n                if (typeof this.brokenAxis !== 'undefined') {\n                    this.brokenAxis.setBreaks(this.options.breaks, false);\n                }\n            }\n            /**\n             * Force Axis to be not-ordinal when breaks are defined.\n             * @private\n             */\n            function onAxisAfterSetOptions() {\n                const axis = this;\n                if (axis.brokenAxis?.hasBreaks) {\n                    axis.options.ordinal = false;\n                }\n            }\n            /**\n             * @private\n             */\n            function onAxisAfterSetTickPositions() {\n                const axis = this, brokenAxis = axis.brokenAxis;\n                if (brokenAxis?.hasBreaks) {\n                    const tickPositions = axis.tickPositions, info = axis.tickPositions.info, newPositions = [];\n                    for (let i = 0; i < tickPositions.length; i++) {\n                        if (!brokenAxis.isInAnyBreak(tickPositions[i])) {\n                            newPositions.push(tickPositions[i]);\n                        }\n                    }\n                    axis.tickPositions = newPositions;\n                    axis.tickPositions.info = info;\n                }\n            }\n            /**\n             * @private\n             */\n            function onAxisInit() {\n                const axis = this;\n                if (!axis.brokenAxis) {\n                    axis.brokenAxis = new Additions(axis);\n                }\n            }\n            /**\n             * @private\n             */\n            function onSeriesAfterGeneratePoints() {\n                const { isDirty, options: { connectNulls }, points, xAxis, yAxis } = this;\n                // Set, or reset visibility of the points. Axis.setBreaks marks\n                // the series as isDirty\n                if (isDirty) {\n                    let i = points.length;\n                    while (i--) {\n                        const point = points[i];\n                        // Respect nulls inside the break (#4275)\n                        const nullGap = point.y === null && connectNulls === false;\n                        const isPointInBreak = (!nullGap && (xAxis?.brokenAxis?.isInAnyBreak(point.x, true) ||\n                            yAxis?.brokenAxis?.isInAnyBreak(point.y, true)));\n                        // Set point.visible if in any break.\n                        // If not in break, reset visible to original value.\n                        point.visible = isPointInBreak ?\n                            false :\n                            point.options.visible !== false;\n                    }\n                }\n            }\n            /**\n             * @private\n             */\n            function onSeriesAfterRender() {\n                this.drawBreaks(this.xAxis, ['x']);\n                this.drawBreaks(this.yAxis, pick(this.pointArrayMap, ['y']));\n            }\n            /**\n             * @private\n             */\n            function seriesDrawBreaks(axis, keys) {\n                const series = this, points = series.points;\n                let breaks, threshold, y;\n                if (axis?.brokenAxis?.hasBreaks) {\n                    const brokenAxis = axis.brokenAxis;\n                    keys.forEach(function (key) {\n                        breaks = brokenAxis?.breakArray || [];\n                        threshold = axis.isXAxis ?\n                            axis.min :\n                            pick(series.options.threshold, axis.min);\n                        // Array of breaks that have been \"zoomed-out\" which means that\n                        // they were shown previously, but now after zoom, they are not\n                        // (#19885).\n                        const breaksOutOfRange = axis?.options?.breaks?.filter(function (brk) {\n                            let isOut = true;\n                            // Iterate to see if \"brk\" is in axis range\n                            for (let i = 0; i < breaks.length; i++) {\n                                const otherBreak = breaks[i];\n                                if (otherBreak.from === brk.from &&\n                                    otherBreak.to === brk.to) {\n                                    isOut = false;\n                                    break;\n                                }\n                            }\n                            return isOut;\n                        });\n                        points.forEach(function (point) {\n                            y = pick(point['stack' + key.toUpperCase()], point[key]);\n                            breaks.forEach(function (brk) {\n                                if (isNumber(threshold) && isNumber(y)) {\n                                    let eventName = '';\n                                    if ((threshold < brk.from && y > brk.to) ||\n                                        (threshold > brk.from && y < brk.from)) {\n                                        eventName = 'pointBreak';\n                                    }\n                                    else if ((threshold < brk.from &&\n                                        y > brk.from &&\n                                        y < brk.to) || (threshold > brk.from &&\n                                        y > brk.to &&\n                                        y < brk.from)) {\n                                        eventName = 'pointInBreak';\n                                    }\n                                    if (eventName) {\n                                        fireEvent(axis, eventName, { point, brk });\n                                    }\n                                }\n                            });\n                            breaksOutOfRange?.forEach(function (brk) {\n                                fireEvent(axis, 'pointOutsideOfBreak', { point, brk });\n                            });\n                        });\n                    });\n                }\n            }\n            /**\n             * Extend getGraphPath by identifying gaps in the data so that we\n             * can draw a gap in the line or area. This was moved from ordinal\n             * axis module to broken axis module as of #5045.\n             *\n             * @private\n             * @function Highcharts.Series#gappedPath\n             *\n             * @return {Highcharts.SVGPathArray}\n             * Gapped path\n             */\n            function seriesGappedPath() {\n                const currentDataGrouping = this.currentDataGrouping, groupingSize = currentDataGrouping?.gapSize, points = this.points.slice(), yAxis = this.yAxis;\n                let gapSize = this.options.gapSize, i = points.length - 1, stack;\n                /**\n                 * Defines when to display a gap in the graph, together with the\n                 * [gapUnit](plotOptions.series.gapUnit) option.\n                 *\n                 * In case when `dataGrouping` is enabled, points can be grouped\n                 * into a larger time span. This can make the grouped points to\n                 * have a greater distance than the absolute value of `gapSize`\n                 * property, which will result in disappearing graph completely.\n                 * To prevent this situation the mentioned distance between\n                 * grouped points is used instead of previously defined\n                 * `gapSize`.\n                 *\n                 * In practice, this option is most often used to visualize gaps\n                 * in time series. In a stock chart, intraday data is available\n                 * for daytime hours, while gaps will appear in nights and\n                 * weekends.\n                 *\n                 * @see [gapUnit](plotOptions.series.gapUnit)\n                 * @see [xAxis.breaks](#xAxis.breaks)\n                 *\n                 * @sample {highstock} stock/plotoptions/series-gapsize/\n                 * Setting the gap size to 2 introduces gaps for weekends in\n                 * daily datasets.\n                 *\n                 * @type      {number}\n                 * @default   0\n                 * @product   highstock\n                 * @requires  modules/broken-axis\n                 * @apioption plotOptions.series.gapSize\n                 */\n                /**\n                 * Together with [gapSize](plotOptions.series.gapSize), this\n                 * option defines where to draw gaps in the graph.\n                 *\n                 * When the `gapUnit` is `\"relative\"` (default), a gap size of 5\n                 * means that if the distance between two points is greater than\n                 * 5 times that of the two closest points, the graph will be\n                 * broken.\n                 *\n                 * When the `gapUnit` is `\"value\"`, the gap is based on absolute\n                 * axis values, which on a datetime axis is milliseconds. This\n                 * also applies to the navigator series that inherits gap\n                 * options from the base series.\n                 *\n                 * @see [gapSize](plotOptions.series.gapSize)\n                 *\n                 * @type       {string}\n                 * @default    relative\n                 * @since      5.0.13\n                 * @product    highstock\n                 * @validvalue [\"relative\", \"value\"]\n                 * @requires   modules/broken-axis\n                 * @apioption  plotOptions.series.gapUnit\n                 */\n                if (gapSize && i > 0) { // #5008\n                    // Gap unit is relative\n                    if (this.options.gapUnit !== 'value') {\n                        gapSize *= this.basePointRange;\n                    }\n                    // Setting a new gapSize in case dataGrouping is enabled\n                    // (#7686)\n                    if (groupingSize &&\n                        groupingSize > gapSize &&\n                        // Except when DG is forced (e.g. from other series)\n                        // and has lower granularity than actual points (#11351)\n                        groupingSize >= this.basePointRange) {\n                        gapSize = groupingSize;\n                    }\n                    // extension for ordinal breaks\n                    let current, next;\n                    while (i--) {\n                        // Reassign next if it is not visible\n                        if (!(next && next.visible !== false)) {\n                            next = points[i + 1];\n                        }\n                        current = points[i];\n                        // Skip iteration if one of the points is not visible\n                        if (next.visible === false || current.visible === false) {\n                            continue;\n                        }\n                        if (next.x - current.x > gapSize) {\n                            const xRange = (current.x + next.x) / 2;\n                            points.splice(// insert after this one\n                            i + 1, 0, {\n                                isNull: true,\n                                x: xRange\n                            });\n                            // For stacked chart generate empty stack items, #6546\n                            if (yAxis.stacking && this.options.stacking) {\n                                stack = yAxis.stacking.stacks[this.stackKey][xRange] = new StackItem(yAxis, yAxis.options.stackLabels, false, xRange, this.stack);\n                                stack.total = 0;\n                            }\n                        }\n                        // Assign current to next for the upcoming iteration\n                        next = current;\n                    }\n                }\n                // Call base method\n                return this.getGraphPath(points);\n            }\n            /* *\n             *\n             *  Class\n             *\n             * */\n            /**\n             * Provides support for broken axes.\n             * @private\n             * @class\n             */\n            class Additions {\n                /* *\n                 *\n                 *  Static Functions\n                 *\n                 * */\n                /**\n                 * @private\n                 */\n                static isInBreak(brk, val) {\n                    const repeat = brk.repeat || Infinity, from = brk.from, length = brk.to - brk.from, test = (val >= from ?\n                        (val - from) % repeat :\n                        repeat - ((from - val) % repeat));\n                    let ret;\n                    if (!brk.inclusive) {\n                        ret = test < length && test !== 0;\n                    }\n                    else {\n                        ret = test <= length;\n                    }\n                    return ret;\n                }\n                /**\n                 * @private\n                 */\n                static lin2Val(val) {\n                    const axis = this;\n                    const brokenAxis = axis.brokenAxis;\n                    const breakArray = brokenAxis && brokenAxis.breakArray;\n                    if (!breakArray || !isNumber(val)) {\n                        return val;\n                    }\n                    let nval = val, brk, i;\n                    for (i = 0; i < breakArray.length; i++) {\n                        brk = breakArray[i];\n                        if (brk.from >= nval) {\n                            break;\n                        }\n                        else if (brk.to < nval) {\n                            nval += brk.len;\n                        }\n                        else if (Additions.isInBreak(brk, nval)) {\n                            nval += brk.len;\n                        }\n                    }\n                    return nval;\n                }\n                /**\n                 * @private\n                 */\n                static val2Lin(val) {\n                    const axis = this;\n                    const brokenAxis = axis.brokenAxis;\n                    const breakArray = brokenAxis && brokenAxis.breakArray;\n                    if (!breakArray || !isNumber(val)) {\n                        return val;\n                    }\n                    let nval = val, brk, i;\n                    for (i = 0; i < breakArray.length; i++) {\n                        brk = breakArray[i];\n                        if (brk.to <= val) {\n                            nval -= brk.len;\n                        }\n                        else if (brk.from >= val) {\n                            break;\n                        }\n                        else if (Additions.isInBreak(brk, val)) {\n                            nval -= (val - brk.from);\n                            break;\n                        }\n                    }\n                    return nval;\n                }\n                /* *\n                 *\n                 *  Constructors\n                 *\n                 * */\n                constructor(axis) {\n                    this.hasBreaks = false;\n                    this.axis = axis;\n                }\n                /* *\n                 *\n                 *  Functions\n                 *\n                 * */\n                /**\n                 * Returns the first break found where the x is larger then break.from\n                 * and smaller then break.to.\n                 *\n                 * @param {number} x\n                 * The number which should be within a break.\n                 *\n                 * @param {Array<Highcharts.XAxisBreaksOptions>} breaks\n                 * The array of breaks to search within.\n                 *\n                 * @return {Highcharts.XAxisBreaksOptions|undefined}\n                 * Returns the first break found that matches, returns false if no break\n                 * is found.\n                 */\n                findBreakAt(x, breaks) {\n                    return find(breaks, function (b) {\n                        return b.from < x && x < b.to;\n                    });\n                }\n                /**\n                 * @private\n                 */\n                isInAnyBreak(val, testKeep) {\n                    const brokenAxis = this, axis = brokenAxis.axis, breaks = axis.options.breaks || [];\n                    let i = breaks.length, inbrk, keep, ret;\n                    if (i && isNumber(val)) {\n                        while (i--) {\n                            if (Additions.isInBreak(breaks[i], val)) {\n                                inbrk = true;\n                                if (!keep) {\n                                    keep = pick(breaks[i].showPoints, !axis.isXAxis);\n                                }\n                            }\n                        }\n                        if (inbrk && testKeep) {\n                            ret = inbrk && !keep;\n                        }\n                        else {\n                            ret = inbrk;\n                        }\n                    }\n                    return ret;\n                }\n                /**\n                 * Dynamically set or unset breaks in an axis. This function in lighter\n                 * than usin Axis.update, and it also preserves animation.\n                 *\n                 * @private\n                 * @function Highcharts.Axis#setBreaks\n                 *\n                 * @param {Array<Highcharts.XAxisBreaksOptions>} [breaks]\n                 * The breaks to add. When `undefined` it removes existing breaks.\n                 *\n                 * @param {boolean} [redraw=true]\n                 * Whether to redraw the chart immediately.\n                 */\n                setBreaks(breaks, redraw) {\n                    const brokenAxis = this;\n                    const axis = brokenAxis.axis;\n                    const hasBreaks = isArray(breaks) &&\n                        !!breaks.length &&\n                        !!Object.keys(breaks[0]).length; // Check for [{}], #16368.\n                    axis.isDirty = brokenAxis.hasBreaks !== hasBreaks;\n                    brokenAxis.hasBreaks = hasBreaks;\n                    if (breaks !== axis.options.breaks) {\n                        axis.options.breaks = axis.userOptions.breaks = breaks;\n                    }\n                    axis.forceRedraw = true; // Force recalculation in setScale\n                    // Recalculate series related to the axis.\n                    axis.series.forEach(function (series) {\n                        series.isDirty = true;\n                    });\n                    if (!hasBreaks && axis.val2lin === Additions.val2Lin) {\n                        // Revert to prototype functions\n                        delete axis.val2lin;\n                        delete axis.lin2val;\n                    }\n                    if (hasBreaks) {\n                        axis.userOptions.ordinal = false;\n                        axis.lin2val = Additions.lin2Val;\n                        axis.val2lin = Additions.val2Lin;\n                        axis.setExtremes = function (newMin, newMax, redraw, animation, eventArguments) {\n                            // If trying to set extremes inside a break, extend min to\n                            // after, and max to before the break ( #3857 )\n                            if (brokenAxis.hasBreaks) {\n                                const breaks = (this.options.breaks || []);\n                                let axisBreak;\n                                while ((axisBreak = brokenAxis.findBreakAt(newMin, breaks))) {\n                                    newMin = axisBreak.to;\n                                }\n                                while ((axisBreak = brokenAxis.findBreakAt(newMax, breaks))) {\n                                    newMax = axisBreak.from;\n                                }\n                                // If both min and max is within the same break.\n                                if (newMax < newMin) {\n                                    newMax = newMin;\n                                }\n                            }\n                            axis.constructor.prototype.setExtremes.call(this, newMin, newMax, redraw, animation, eventArguments);\n                        };\n                        axis.setAxisTranslation = function () {\n                            axis.constructor.prototype.setAxisTranslation.call(this);\n                            brokenAxis.unitLength = void 0;\n                            if (brokenAxis.hasBreaks) {\n                                const breaks = axis.options.breaks || [], \n                                // Temporary one:\n                                breakArrayT = [], breakArray = [], pointRangePadding = pick(axis.pointRangePadding, 0);\n                                let length = 0, inBrk, repeat, min = axis.userMin || axis.min, max = axis.userMax || axis.max, start, i;\n                                // Min & max check (#4247)\n                                breaks.forEach(function (brk) {\n                                    repeat = brk.repeat || Infinity;\n                                    if (isNumber(min) && isNumber(max)) {\n                                        if (Additions.isInBreak(brk, min)) {\n                                            min += ((brk.to % repeat) -\n                                                (min % repeat));\n                                        }\n                                        if (Additions.isInBreak(brk, max)) {\n                                            max -= ((max % repeat) -\n                                                (brk.from % repeat));\n                                        }\n                                    }\n                                });\n                                // Construct an array holding all breaks in the axis\n                                breaks.forEach(function (brk) {\n                                    start = brk.from;\n                                    repeat = brk.repeat || Infinity;\n                                    if (isNumber(min) && isNumber(max)) {\n                                        while (start - repeat > min) {\n                                            start -= repeat;\n                                        }\n                                        while (start < min) {\n                                            start += repeat;\n                                        }\n                                        for (i = start; i < max; i += repeat) {\n                                            breakArrayT.push({\n                                                value: i,\n                                                move: 'in'\n                                            });\n                                            breakArrayT.push({\n                                                value: i + brk.to - brk.from,\n                                                move: 'out',\n                                                size: brk.breakSize\n                                            });\n                                        }\n                                    }\n                                });\n                                breakArrayT.sort(function (a, b) {\n                                    return ((a.value === b.value) ?\n                                        ((a.move === 'in' ? 0 : 1) -\n                                            (b.move === 'in' ? 0 : 1)) :\n                                        a.value - b.value);\n                                });\n                                // Simplify the breaks\n                                inBrk = 0;\n                                start = min;\n                                breakArrayT.forEach(function (brk) {\n                                    inBrk += (brk.move === 'in' ? 1 : -1);\n                                    if (inBrk === 1 && brk.move === 'in') {\n                                        start = brk.value;\n                                    }\n                                    if (inBrk === 0 && isNumber(start)) {\n                                        breakArray.push({\n                                            from: start,\n                                            to: brk.value,\n                                            len: brk.value - start - (brk.size || 0)\n                                        });\n                                        length += (brk.value -\n                                            start -\n                                            (brk.size || 0));\n                                    }\n                                });\n                                brokenAxis.breakArray = breakArray;\n                                // Used with staticScale, and below the actual axis\n                                // length, when breaks are substracted.\n                                if (isNumber(min) &&\n                                    isNumber(max) &&\n                                    isNumber(axis.min)) {\n                                    brokenAxis.unitLength = max - min - length +\n                                        pointRangePadding;\n                                    fireEvent(axis, 'afterBreaks');\n                                    if (axis.staticScale) {\n                                        axis.transA = axis.staticScale;\n                                    }\n                                    else if (brokenAxis.unitLength) {\n                                        axis.transA *=\n                                            (max - axis.min + pointRangePadding) /\n                                                brokenAxis.unitLength;\n                                    }\n                                    if (pointRangePadding) {\n                                        axis.minPixelPadding =\n                                            axis.transA * (axis.minPointOffset || 0);\n                                    }\n                                    axis.min = min;\n                                    axis.max = max;\n                                }\n                            }\n                        };\n                    }\n                    if (pick(redraw, true)) {\n                        axis.chart.redraw();\n                    }\n                }\n            }\n            BrokenAxis.Additions = Additions;\n        })(BrokenAxis || (BrokenAxis = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return BrokenAxis;\n    });\n    _registerModule(_modules, 'Core/Axis/GridAxis.js', [_modules['Core/Axis/Axis.js'], _modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (Axis, H, U) {\n        /* *\n         *\n         *  (c) 2016 Highsoft AS\n         *  Authors: Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { composed, dateFormats } = H;\n        const { addEvent, defined, erase, find, isArray, isNumber, merge, pick, pushUnique, timeUnits, wrap } = U;\n        /* *\n         *\n         *  Enums\n         *\n         * */\n        /**\n         * Enum for which side the axis is on. Maps to axis.side.\n         * @private\n         */\n        var GridAxisSide;\n        (function (GridAxisSide) {\n            GridAxisSide[GridAxisSide[\"top\"] = 0] = \"top\";\n            GridAxisSide[GridAxisSide[\"right\"] = 1] = \"right\";\n            GridAxisSide[GridAxisSide[\"bottom\"] = 2] = \"bottom\";\n            GridAxisSide[GridAxisSide[\"left\"] = 3] = \"left\";\n        })(GridAxisSide || (GridAxisSide = {}));\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * @private\n         */\n        function argsToArray(args) {\n            return Array.prototype.slice.call(args, 1);\n        }\n        /**\n         * @private\n         */\n        function isObject(x) {\n            // Always use strict mode\n            return U.isObject(x, true);\n        }\n        /**\n         * @private\n         */\n        function applyGridOptions(axis) {\n            const options = axis.options;\n            // Center-align by default\n            /*\n            if (!options.labels) {\n                options.labels = {};\n            }\n            */\n            options.labels.align = pick(options.labels.align, 'center');\n            // @todo: Check against tickLabelPlacement between/on etc\n            /* Prevents adding the last tick label if the axis is not a category\n               axis.\n               Since numeric labels are normally placed at starts and ends of a\n               range of value, and this module makes the label point at the value,\n               an \"extra\" label would appear. */\n            if (!axis.categories) {\n                options.showLastLabel = false;\n            }\n            // Prevents rotation of labels when squished, as rotating them would not\n            // help.\n            axis.labelRotation = 0;\n            options.labels.rotation = 0;\n            // Allow putting ticks closer than their data points.\n            options.minTickInterval = 1;\n        }\n        /**\n         * Extends axis class with grid support.\n         * @private\n         */\n        function compose(AxisClass, ChartClass, TickClass) {\n            if (pushUnique(composed, compose)) {\n                AxisClass.keepProps.push('grid');\n                AxisClass.prototype.getMaxLabelDimensions = getMaxLabelDimensions;\n                wrap(AxisClass.prototype, 'unsquish', wrapUnsquish);\n                wrap(AxisClass.prototype, 'getOffset', wrapGetOffset);\n                // Add event handlers\n                addEvent(AxisClass, 'init', onInit);\n                addEvent(AxisClass, 'afterGetTitlePosition', onAfterGetTitlePosition);\n                addEvent(AxisClass, 'afterInit', onAfterInit);\n                addEvent(AxisClass, 'afterRender', onAfterRender);\n                addEvent(AxisClass, 'afterSetAxisTranslation', onAfterSetAxisTranslation);\n                addEvent(AxisClass, 'afterSetOptions', onAfterSetOptions);\n                addEvent(AxisClass, 'afterSetOptions', onAfterSetOptions2);\n                addEvent(AxisClass, 'afterSetScale', onAfterSetScale);\n                addEvent(AxisClass, 'afterTickSize', onAfterTickSize);\n                addEvent(AxisClass, 'trimTicks', onTrimTicks);\n                addEvent(AxisClass, 'destroy', onDestroy);\n                addEvent(ChartClass, 'afterSetChartSize', onChartAfterSetChartSize);\n                addEvent(TickClass, 'afterGetLabelPosition', onTickAfterGetLabelPosition);\n                addEvent(TickClass, 'labelFormat', onTickLabelFormat);\n            }\n            return AxisClass;\n        }\n        /**\n         * Get the largest label width and height.\n         *\n         * @private\n         * @function Highcharts.Axis#getMaxLabelDimensions\n         *\n         * @param {Highcharts.Dictionary<Highcharts.Tick>} ticks\n         * All the ticks on one axis.\n         *\n         * @param {Array<number|string>} tickPositions\n         * All the tick positions on one axis.\n         *\n         * @return {Highcharts.SizeObject}\n         * Object containing the properties height and width.\n         *\n         * @todo Move this to the generic axis implementation, as it is used there.\n         */\n        function getMaxLabelDimensions(ticks, tickPositions) {\n            const dimensions = {\n                width: 0,\n                height: 0\n            };\n            tickPositions.forEach(function (pos) {\n                const tick = ticks[pos];\n                let labelHeight = 0, labelWidth = 0, label;\n                if (isObject(tick)) {\n                    label = isObject(tick.label) ? tick.label : {};\n                    // Find width and height of label\n                    labelHeight = label.getBBox ? label.getBBox().height : 0;\n                    if (label.textStr && !isNumber(label.textPxLength)) {\n                        label.textPxLength = label.getBBox().width;\n                    }\n                    labelWidth = isNumber(label.textPxLength) ?\n                        // Math.round ensures crisp lines\n                        Math.round(label.textPxLength) :\n                        0;\n                    if (label.textStr) {\n                        // Set the tickWidth same as the label width after ellipsis\n                        // applied #10281\n                        labelWidth = Math.round(label.getBBox().width);\n                    }\n                    // Update the result if width and/or height are larger\n                    dimensions.height = Math.max(labelHeight, dimensions.height);\n                    dimensions.width = Math.max(labelWidth, dimensions.width);\n                }\n            });\n            // For tree grid, add indentation\n            if (this.options.type === 'treegrid' &&\n                this.treeGrid &&\n                this.treeGrid.mapOfPosToGridNode) {\n                const treeDepth = this.treeGrid.mapOfPosToGridNode[-1].height || 0;\n                dimensions.width += (this.options.labels.indentation *\n                    (treeDepth - 1));\n            }\n            return dimensions;\n        }\n        /**\n         * Handle columns and getOffset.\n         * @private\n         */\n        function wrapGetOffset(proceed) {\n            const { grid } = this, \n            // On the left side we handle the columns first because the offset is\n            // calculated from the plot area and out\n            columnsFirst = this.side === 3;\n            if (!columnsFirst) {\n                proceed.apply(this);\n            }\n            if (!grid?.isColumn) {\n                let columns = grid?.columns || [];\n                if (columnsFirst) {\n                    columns = columns.slice().reverse();\n                }\n                columns\n                    .forEach((column) => {\n                    column.getOffset();\n                });\n            }\n            if (columnsFirst) {\n                proceed.apply(this);\n            }\n        }\n        /**\n         * @private\n         */\n        function onAfterGetTitlePosition(e) {\n            const axis = this;\n            const options = axis.options;\n            const gridOptions = options.grid || {};\n            if (gridOptions.enabled === true) {\n                // compute anchor points for each of the title align options\n                const { axisTitle, height: axisHeight, horiz, left: axisLeft, offset, opposite, options, top: axisTop, width: axisWidth } = axis;\n                const tickSize = axis.tickSize();\n                const titleWidth = axisTitle && axisTitle.getBBox().width;\n                const xOption = options.title.x;\n                const yOption = options.title.y;\n                const titleMargin = pick(options.title.margin, horiz ? 5 : 10);\n                const titleFontSize = axisTitle ? axis.chart.renderer.fontMetrics(axisTitle).f : 0;\n                const crispCorr = tickSize ? tickSize[0] / 2 : 0;\n                // TODO account for alignment\n                // the position in the perpendicular direction of the axis\n                const offAxis = ((horiz ? axisTop + axisHeight : axisLeft) +\n                    (horiz ? 1 : -1) * // horizontal axis reverses the margin\n                        (opposite ? -1 : 1) * // so does opposite axes\n                        crispCorr +\n                    (axis.side === GridAxisSide.bottom ? titleFontSize : 0));\n                e.titlePosition.x = horiz ?\n                    axisLeft - (titleWidth || 0) / 2 - titleMargin + xOption :\n                    offAxis + (opposite ? axisWidth : 0) + offset + xOption;\n                e.titlePosition.y = horiz ?\n                    (offAxis -\n                        (opposite ? axisHeight : 0) +\n                        (opposite ? titleFontSize : -titleFontSize) / 2 +\n                        offset +\n                        yOption) :\n                    axisTop - titleMargin + yOption;\n            }\n        }\n        /**\n         * @private\n         */\n        function onAfterInit() {\n            const axis = this;\n            const { chart, options: { grid: gridOptions = {} }, userOptions } = axis;\n            if (gridOptions.enabled) {\n                applyGridOptions(axis);\n            }\n            if (gridOptions.columns) {\n                const columns = axis.grid.columns = [];\n                let columnIndex = axis.grid.columnIndex = 0;\n                // Handle columns, each column is a grid axis\n                while (++columnIndex < gridOptions.columns.length) {\n                    const columnOptions = merge(userOptions, gridOptions.columns[columnIndex], {\n                        isInternal: true,\n                        linkedTo: 0,\n                        // Disable by default the scrollbar on the grid axis\n                        scrollbar: {\n                            enabled: false\n                        }\n                    }, \n                    // Avoid recursion\n                    {\n                        grid: {\n                            columns: void 0\n                        }\n                    });\n                    const column = new Axis(axis.chart, columnOptions, 'yAxis');\n                    column.grid.isColumn = true;\n                    column.grid.columnIndex = columnIndex;\n                    // Remove column axis from chart axes array, and place it\n                    // in the columns array.\n                    erase(chart.axes, column);\n                    erase(chart[axis.coll] || [], column);\n                    columns.push(column);\n                }\n            }\n        }\n        /**\n         * Draw an extra line on the far side of the outermost axis,\n         * creating floor/roof/wall of a grid. And some padding.\n         * ```\n         * Make this:\n         *             (axis.min) __________________________ (axis.max)\n         *                           |    |    |    |    |\n         * Into this:\n         *             (axis.min) __________________________ (axis.max)\n         *                        ___|____|____|____|____|__\n         * ```\n         * @private\n         */\n        function onAfterRender() {\n            const axis = this, { axisTitle, grid, options } = axis, gridOptions = options.grid || {};\n            if (gridOptions.enabled === true) {\n                const min = axis.min || 0, max = axis.max || 0, firstTick = axis.ticks[axis.tickPositions[0]];\n                // Adjust the title max width to the column width (#19657)\n                if (axisTitle &&\n                    !axis.chart.styledMode &&\n                    firstTick?.slotWidth &&\n                    !axis.options.title.style.width) {\n                    axisTitle.css({ width: `${firstTick.slotWidth}px` });\n                }\n                // @todo acutual label padding (top, bottom, left, right)\n                axis.maxLabelDimensions = axis.getMaxLabelDimensions(axis.ticks, axis.tickPositions);\n                // Remove right wall before rendering if updating\n                if (axis.rightWall) {\n                    axis.rightWall.destroy();\n                }\n                /*\n                Draw an extra axis line on outer axes\n                            >\n                Make this:    |______|______|______|___\n\n                            > _________________________\n                Into this:    |______|______|______|__|\n                                                        */\n                if (axis.grid && axis.grid.isOuterAxis() && axis.axisLine) {\n                    const lineWidth = options.lineWidth;\n                    if (lineWidth) {\n                        const linePath = axis.getLinePath(lineWidth), startPoint = linePath[0], endPoint = linePath[1], \n                        // Negate distance if top or left axis\n                        // Subtract 1px to draw the line at the end of the tick\n                        tickLength = (axis.tickSize('tick') || [1])[0], distance = (tickLength - 1) * ((axis.side === GridAxisSide.top ||\n                            axis.side === GridAxisSide.left) ? -1 : 1);\n                        // If axis is horizontal, reposition line path vertically\n                        if (startPoint[0] === 'M' && endPoint[0] === 'L') {\n                            if (axis.horiz) {\n                                startPoint[2] += distance;\n                                endPoint[2] += distance;\n                            }\n                            else {\n                                startPoint[1] += distance;\n                                endPoint[1] += distance;\n                            }\n                        }\n                        // If it doesn't exist, add an upper and lower border\n                        // for the vertical grid axis.\n                        if (!axis.horiz && axis.chart.marginRight) {\n                            const upperBorderStartPoint = startPoint, upperBorderEndPoint = [\n                                'L',\n                                axis.left,\n                                startPoint[2] || 0\n                            ], upperBorderPath = [\n                                upperBorderStartPoint,\n                                upperBorderEndPoint\n                            ], lowerBorderEndPoint = [\n                                'L',\n                                axis.chart.chartWidth - axis.chart.marginRight,\n                                axis.toPixels(max + axis.tickmarkOffset)\n                            ], lowerBorderStartPoint = [\n                                'M',\n                                endPoint[1] || 0,\n                                axis.toPixels(max + axis.tickmarkOffset)\n                            ], lowerBorderPath = [\n                                lowerBorderStartPoint,\n                                lowerBorderEndPoint\n                            ];\n                            if (!axis.grid.upperBorder && min % 1 !== 0) {\n                                axis.grid.upperBorder = axis.grid.renderBorder(upperBorderPath);\n                            }\n                            if (axis.grid.upperBorder) {\n                                axis.grid.upperBorder.attr({\n                                    stroke: options.lineColor,\n                                    'stroke-width': options.lineWidth\n                                });\n                                axis.grid.upperBorder.animate({\n                                    d: upperBorderPath\n                                });\n                            }\n                            if (!axis.grid.lowerBorder && max % 1 !== 0) {\n                                axis.grid.lowerBorder = axis.grid.renderBorder(lowerBorderPath);\n                            }\n                            if (axis.grid.lowerBorder) {\n                                axis.grid.lowerBorder.attr({\n                                    stroke: options.lineColor,\n                                    'stroke-width': options.lineWidth\n                                });\n                                axis.grid.lowerBorder.animate({\n                                    d: lowerBorderPath\n                                });\n                            }\n                        }\n                        // Render an extra line parallel to the existing axes, to\n                        // close the grid.\n                        if (!axis.grid.axisLineExtra) {\n                            axis.grid.axisLineExtra = axis.grid.renderBorder(linePath);\n                        }\n                        else {\n                            axis.grid.axisLineExtra.attr({\n                                stroke: options.lineColor,\n                                'stroke-width': options.lineWidth\n                            });\n                            axis.grid.axisLineExtra.animate({\n                                d: linePath\n                            });\n                        }\n                        // show or hide the line depending on options.showEmpty\n                        axis.axisLine[axis.showAxis ? 'show' : 'hide']();\n                    }\n                }\n                (grid && grid.columns || []).forEach((column) => column.render());\n                // Manipulate the tick mark visibility\n                // based on the axis.max- allows smooth scrolling.\n                if (!axis.horiz &&\n                    axis.chart.hasRendered &&\n                    (axis.scrollbar ||\n                        (axis.linkedParent && axis.linkedParent.scrollbar)) &&\n                    axis.tickPositions.length) {\n                    const tickmarkOffset = axis.tickmarkOffset, lastTick = axis.tickPositions[axis.tickPositions.length - 1], firstTick = axis.tickPositions[0];\n                    let label, tickMark;\n                    while ((label = axis.hiddenLabels.pop()) && label.element) {\n                        label.show(); // #15453\n                    }\n                    while ((tickMark = axis.hiddenMarks.pop()) &&\n                        tickMark.element) {\n                        tickMark.show(); // #16439\n                    }\n                    // Hide/show first tick label.\n                    label = axis.ticks[firstTick].label;\n                    if (label) {\n                        if (min - firstTick > tickmarkOffset) {\n                            axis.hiddenLabels.push(label.hide());\n                        }\n                        else {\n                            label.show();\n                        }\n                    }\n                    // Hide/show last tick mark/label.\n                    label = axis.ticks[lastTick].label;\n                    if (label) {\n                        if (lastTick - max > tickmarkOffset) {\n                            axis.hiddenLabels.push(label.hide());\n                        }\n                        else {\n                            label.show();\n                        }\n                    }\n                    const mark = axis.ticks[lastTick].mark;\n                    if (mark &&\n                        lastTick - max < tickmarkOffset &&\n                        lastTick - max > 0 && axis.ticks[lastTick].isLast) {\n                        axis.hiddenMarks.push(mark.hide());\n                    }\n                }\n            }\n        }\n        /**\n         * @private\n         */\n        function onAfterSetAxisTranslation() {\n            const axis = this;\n            const tickInfo = axis.tickPositions && axis.tickPositions.info;\n            const options = axis.options;\n            const gridOptions = options.grid || {};\n            const userLabels = axis.userOptions.labels || {};\n            // Fire this only for the Gantt type chart, #14868.\n            if (gridOptions.enabled) {\n                if (axis.horiz) {\n                    axis.series.forEach((series) => {\n                        series.options.pointRange = 0;\n                    });\n                    // Lower level time ticks, like hours or minutes, represent\n                    // points in time and not ranges. These should be aligned\n                    // left in the grid cell by default. The same applies to\n                    // years of higher order.\n                    if (tickInfo &&\n                        options.dateTimeLabelFormats &&\n                        options.labels &&\n                        !defined(userLabels.align) &&\n                        (options.dateTimeLabelFormats[tickInfo.unitName]\n                            .range === false ||\n                            tickInfo.count > 1 // years\n                        )) {\n                        options.labels.align = 'left';\n                        if (!defined(userLabels.x)) {\n                            options.labels.x = 3;\n                        }\n                    }\n                }\n                else {\n                    // Don't trim ticks which not in min/max range but\n                    // they are still in the min/max plus tickInterval.\n                    if (this.options.type !== 'treegrid' &&\n                        axis.grid &&\n                        axis.grid.columns) {\n                        this.minPointOffset = this.tickInterval;\n                    }\n                }\n            }\n        }\n        /**\n         * Creates a left and right wall on horizontal axes:\n         * - Places leftmost tick at the start of the axis, to create a left\n         *   wall\n         * - Ensures that the rightmost tick is at the end of the axis, to\n         *   create a right wall.\n         * @private\n         */\n        function onAfterSetOptions(e) {\n            const options = this.options, userOptions = e.userOptions, gridOptions = ((options && isObject(options.grid)) ? options.grid : {});\n            let gridAxisOptions;\n            if (gridOptions.enabled === true) {\n                // Merge the user options into default grid axis options so\n                // that when a user option is set, it takes presedence.\n                gridAxisOptions = merge(true, {\n                    className: ('highcharts-grid-axis ' + (userOptions.className || '')),\n                    dateTimeLabelFormats: {\n                        hour: {\n                            list: ['%H:%M', '%H']\n                        },\n                        day: {\n                            list: ['%A, %e. %B', '%a, %e. %b', '%E']\n                        },\n                        week: {\n                            list: ['Week %W', 'W%W']\n                        },\n                        month: {\n                            list: ['%B', '%b', '%o']\n                        }\n                    },\n                    grid: {\n                        borderWidth: 1\n                    },\n                    labels: {\n                        padding: 2,\n                        style: {\n                            fontSize: '0.9em'\n                        }\n                    },\n                    margin: 0,\n                    title: {\n                        text: null,\n                        reserveSpace: false,\n                        rotation: 0,\n                        style: {\n                            textOverflow: 'ellipsis'\n                        }\n                    },\n                    // In a grid axis, only allow one unit of certain types,\n                    // for example we shouln't have one grid cell spanning\n                    // two days.\n                    units: [[\n                            'millisecond',\n                            [1, 10, 100]\n                        ], [\n                            'second',\n                            [1, 10]\n                        ], [\n                            'minute',\n                            [1, 5, 15]\n                        ], [\n                            'hour',\n                            [1, 6]\n                        ], [\n                            'day',\n                            [1]\n                        ], [\n                            'week',\n                            [1]\n                        ], [\n                            'month',\n                            [1]\n                        ], [\n                            'year',\n                            null\n                        ]]\n                }, userOptions);\n                // X-axis specific options\n                if (this.coll === 'xAxis') {\n                    // For linked axes, tickPixelInterval is used only if\n                    // the tickPositioner below doesn't run or returns\n                    // undefined (like multiple years)\n                    if (defined(userOptions.linkedTo) &&\n                        !defined(userOptions.tickPixelInterval)) {\n                        gridAxisOptions.tickPixelInterval = 350;\n                    }\n                    // For the secondary grid axis, use the primary axis'\n                    // tick intervals and return ticks one level higher.\n                    if (\n                    // Check for tick pixel interval in options\n                    !defined(userOptions.tickPixelInterval) &&\n                        // Only for linked axes\n                        defined(userOptions.linkedTo) &&\n                        !defined(userOptions.tickPositioner) &&\n                        !defined(userOptions.tickInterval) &&\n                        !defined(userOptions.units)) {\n                        gridAxisOptions.tickPositioner = function (min, max) {\n                            const parentInfo = (this.linkedParent &&\n                                this.linkedParent.tickPositions &&\n                                this.linkedParent.tickPositions.info);\n                            if (parentInfo) {\n                                const units = (gridAxisOptions.units || []);\n                                let unitIdx, count = 1, unitName = 'year';\n                                for (let i = 0; i < units.length; i++) {\n                                    const unit = units[i];\n                                    if (unit && unit[0] === parentInfo.unitName) {\n                                        unitIdx = i;\n                                        break;\n                                    }\n                                }\n                                // Get the first allowed count on the next unit.\n                                const unit = (isNumber(unitIdx) && units[unitIdx + 1]);\n                                if (unit) {\n                                    unitName = unit[0] || 'year';\n                                    const counts = unit[1];\n                                    count = counts && counts[0] || 1;\n                                    // In case the base X axis shows years, make the\n                                    // secondary axis show ten times the years (#11427)\n                                }\n                                else if (parentInfo.unitName === 'year') {\n                                    // unitName is 'year'\n                                    count = parentInfo.count * 10;\n                                }\n                                const unitRange = timeUnits[unitName];\n                                this.tickInterval = unitRange * count;\n                                return this.chart.time.getTimeTicks({ unitRange, count, unitName }, min, max, this.options.startOfWeek);\n                            }\n                        };\n                    }\n                }\n                // Now merge the combined options into the axis options\n                merge(true, this.options, gridAxisOptions);\n                if (this.horiz) {\n                    /*               _________________________\n                    Make this:    ___|_____|_____|_____|__|\n                                    ^                     ^\n                                    _________________________\n                    Into this:    |_____|_____|_____|_____|\n                                        ^                 ^    */\n                    options.minPadding = pick(userOptions.minPadding, 0);\n                    options.maxPadding = pick(userOptions.maxPadding, 0);\n                }\n                // If borderWidth is set, then use its value for tick and\n                // line width.\n                if (isNumber(options.grid.borderWidth)) {\n                    options.tickWidth = options.lineWidth =\n                        gridOptions.borderWidth;\n                }\n            }\n        }\n        /**\n         * @private\n         */\n        function onAfterSetOptions2(e) {\n            const axis = this;\n            const userOptions = e.userOptions;\n            const gridOptions = userOptions && userOptions.grid || {};\n            const columns = gridOptions.columns;\n            // Add column options to the parent axis. Children has their column options\n            // set on init in onGridAxisAfterInit.\n            if (gridOptions.enabled && columns) {\n                merge(true, axis.options, columns[0]);\n            }\n        }\n        /**\n         * Handle columns and setScale.\n         * @private\n         */\n        function onAfterSetScale() {\n            const axis = this;\n            (axis.grid.columns || []).forEach((column) => column.setScale());\n        }\n        /**\n         * Draw vertical axis ticks extra long to create cell floors and roofs.\n         * Overrides the tickLength for vertical axes.\n         * @private\n         */\n        function onAfterTickSize(e) {\n            const { horiz, maxLabelDimensions, options: { grid: gridOptions = {} } } = this;\n            if (gridOptions.enabled && maxLabelDimensions) {\n                const labelPadding = this.options.labels.distance * 2;\n                const distance = horiz ?\n                    (gridOptions.cellHeight ||\n                        labelPadding + maxLabelDimensions.height) :\n                    labelPadding + maxLabelDimensions.width;\n                if (isArray(e.tickSize)) {\n                    e.tickSize[0] = distance;\n                }\n                else {\n                    e.tickSize = [distance, 0];\n                }\n            }\n        }\n        /**\n         * @private\n         */\n        function onChartAfterSetChartSize() {\n            this.axes.forEach((axis) => {\n                (axis.grid && axis.grid.columns || []).forEach((column) => {\n                    column.setAxisSize();\n                    column.setAxisTranslation();\n                });\n            });\n        }\n        /**\n         * @private\n         */\n        function onDestroy(e) {\n            const { grid } = this;\n            (grid.columns || []).forEach((column) => column.destroy(e.keepEvents));\n            grid.columns = void 0;\n        }\n        /**\n         * Wraps axis init to draw cell walls on vertical axes.\n         * @private\n         */\n        function onInit(e) {\n            const axis = this;\n            const userOptions = e.userOptions || {};\n            const gridOptions = userOptions.grid || {};\n            if (gridOptions.enabled && defined(gridOptions.borderColor)) {\n                userOptions.tickColor = userOptions.lineColor = (gridOptions.borderColor);\n            }\n            if (!axis.grid) {\n                axis.grid = new GridAxisAdditions(axis);\n            }\n            axis.hiddenLabels = [];\n            axis.hiddenMarks = [];\n        }\n        /**\n         * Center tick labels in cells.\n         * @private\n         */\n        function onTickAfterGetLabelPosition(e) {\n            const tick = this, label = tick.label, axis = tick.axis, reversed = axis.reversed, chart = axis.chart, options = axis.options, gridOptions = options.grid || {}, labelOpts = axis.options.labels, align = labelOpts.align, \n            // verticalAlign is currently not supported for axis.labels.\n            verticalAlign = 'middle', // labelOpts.verticalAlign,\n            side = GridAxisSide[axis.side], tickmarkOffset = e.tickmarkOffset, tickPositions = axis.tickPositions, tickPos = tick.pos - tickmarkOffset, nextTickPos = (isNumber(tickPositions[e.index + 1]) ?\n                tickPositions[e.index + 1] - tickmarkOffset :\n                (axis.max || 0) + tickmarkOffset), tickSize = axis.tickSize('tick'), tickWidth = tickSize ? tickSize[0] : 0, crispCorr = tickSize ? tickSize[1] / 2 : 0;\n            // Only center tick labels in grid axes\n            if (gridOptions.enabled === true) {\n                let bottom, top, left, right;\n                // Calculate top and bottom positions of the cell.\n                if (side === 'top') {\n                    bottom = axis.top + axis.offset;\n                    top = bottom - tickWidth;\n                }\n                else if (side === 'bottom') {\n                    top = chart.chartHeight - axis.bottom + axis.offset;\n                    bottom = top + tickWidth;\n                }\n                else {\n                    bottom = axis.top + axis.len - (axis.translate(reversed ? nextTickPos : tickPos) || 0);\n                    top = axis.top + axis.len - (axis.translate(reversed ? tickPos : nextTickPos) || 0);\n                }\n                // Calculate left and right positions of the cell.\n                if (side === 'right') {\n                    left = chart.chartWidth - axis.right + axis.offset;\n                    right = left + tickWidth;\n                }\n                else if (side === 'left') {\n                    right = axis.left + axis.offset;\n                    left = right - tickWidth;\n                }\n                else {\n                    left = Math.round(axis.left + (axis.translate(reversed ? nextTickPos : tickPos) || 0)) - crispCorr;\n                    right = Math.min(// #15742\n                    Math.round(axis.left + (axis.translate(reversed ? tickPos : nextTickPos) || 0)) - crispCorr, axis.left + axis.len);\n                }\n                tick.slotWidth = right - left;\n                // Calculate the positioning of the label based on\n                // alignment.\n                e.pos.x = (align === 'left' ?\n                    left :\n                    align === 'right' ?\n                        right :\n                        left + ((right - left) / 2) // default to center\n                );\n                e.pos.y = (verticalAlign === 'top' ?\n                    top :\n                    verticalAlign === 'bottom' ?\n                        bottom :\n                        top + ((bottom - top) / 2) // default to middle\n                );\n                if (label) {\n                    const lblMetrics = chart.renderer.fontMetrics(label), labelHeight = label.getBBox().height;\n                    // Adjustment to y position to align the label correctly.\n                    // Would be better to have a setter or similar for this.\n                    if (!labelOpts.useHTML) {\n                        const lines = Math.round(labelHeight / lblMetrics.h);\n                        e.pos.y += (\n                        // Center the label\n                        // TODO: why does this actually center the label?\n                        ((lblMetrics.b - (lblMetrics.h - lblMetrics.f)) / 2) +\n                            // Adjust for height of additional lines.\n                            -(((lines - 1) * lblMetrics.h) / 2));\n                    }\n                    else {\n                        e.pos.y += (\n                        // Readjust yCorr in htmlUpdateTransform\n                        lblMetrics.b +\n                            // Adjust for height of html label\n                            -(labelHeight / 2));\n                    }\n                }\n                e.pos.x += (axis.horiz && labelOpts.x) || 0;\n            }\n        }\n        /**\n         * @private\n         */\n        function onTickLabelFormat(ctx) {\n            const { axis, value } = ctx;\n            if (axis.options.grid &&\n                axis.options.grid.enabled) {\n                const tickPos = axis.tickPositions;\n                const series = (axis.linkedParent || axis).series[0];\n                const isFirst = value === tickPos[0];\n                const isLast = value === tickPos[tickPos.length - 1];\n                const point = series && find(series.options.data, function (p) {\n                    return p[axis.isXAxis ? 'x' : 'y'] === value;\n                });\n                let pointCopy;\n                if (point && series.is('gantt')) {\n                    // For the Gantt set point aliases to the pointCopy\n                    // to do not change the original point\n                    pointCopy = merge(point);\n                    H.seriesTypes.gantt.prototype.pointClass\n                        .setGanttPointAliases(pointCopy);\n                }\n                // Make additional properties available for the\n                // formatter\n                ctx.isFirst = isFirst;\n                ctx.isLast = isLast;\n                ctx.point = pointCopy;\n            }\n        }\n        /**\n         * Makes tick labels which are usually ignored in a linked axis\n         * displayed if they are within range of linkedParent.min.\n         * ```\n         *                        _____________________________\n         *                        |   |       |       |       |\n         * Make this:             |   |   2   |   3   |   4   |\n         *                        |___|_______|_______|_______|\n         *                          ^\n         *                        _____________________________\n         *                        |   |       |       |       |\n         * Into this:             | 1 |   2   |   3   |   4   |\n         *                        |___|_______|_______|_______|\n         *                          ^\n         * ```\n         * @private\n         * @todo Does this function do what the drawing says? Seems to affect\n         *       ticks and not the labels directly?\n         */\n        function onTrimTicks() {\n            const axis = this, chart = axis.chart, options = axis.options, gridOptions = options.grid || {}, categoryAxis = axis.categories, tickPositions = axis.tickPositions, firstPos = tickPositions[0], secondPos = tickPositions[1], lastPos = tickPositions[tickPositions.length - 1], beforeLastPos = tickPositions[tickPositions.length - 2], linkedMin = axis.linkedParent && axis.linkedParent.min, linkedMax = axis.linkedParent && axis.linkedParent.max, min = linkedMin || axis.min, max = linkedMax || axis.max, tickInterval = axis.tickInterval, startLessThanMin = ( // #19845\n            isNumber(min) &&\n                min >= firstPos + tickInterval &&\n                min < secondPos), endMoreThanMin = (isNumber(min) &&\n                firstPos < min &&\n                firstPos + tickInterval > min), startLessThanMax = (isNumber(max) &&\n                lastPos > max &&\n                lastPos - tickInterval < max), endMoreThanMax = (isNumber(max) &&\n                max <= lastPos - tickInterval &&\n                max > beforeLastPos);\n            if (gridOptions.enabled === true &&\n                !categoryAxis &&\n                (axis.isXAxis || axis.isLinked)) {\n                if ((endMoreThanMin || startLessThanMin) && !options.startOnTick) {\n                    tickPositions[0] = min;\n                }\n                if ((startLessThanMax || endMoreThanMax) && !options.endOnTick) {\n                    tickPositions[tickPositions.length - 1] = max;\n                }\n            }\n        }\n        /**\n         * Avoid altering tickInterval when reserving space.\n         * @private\n         */\n        function wrapUnsquish(proceed) {\n            const axis = this;\n            const { options: { grid: gridOptions = {} } } = axis;\n            if (gridOptions.enabled === true && axis.categories) {\n                return axis.tickInterval;\n            }\n            return proceed.apply(axis, argsToArray(arguments));\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Additions for grid axes.\n         * @private\n         * @class\n         */\n        class GridAxisAdditions {\n            /* *\n            *\n            *  Constructors\n            *\n            * */\n            constructor(axis) {\n                this.axis = axis;\n            }\n            /* *\n            *\n            *  Functions\n            *\n            * */\n            /**\n             * Checks if an axis is the outer axis in its dimension. Since\n             * axes are placed outwards in order, the axis with the highest\n             * index is the outermost axis.\n             *\n             * Example: If there are multiple x-axes at the top of the chart,\n             * this function returns true if the axis supplied is the last\n             * of the x-axes.\n             *\n             * @private\n             *\n             * @return {boolean}\n             * True if the axis is the outermost axis in its dimension; false if\n             * not.\n             */\n            isOuterAxis() {\n                const axis = this.axis;\n                const chart = axis.chart;\n                const columnIndex = axis.grid.columnIndex;\n                const columns = (axis.linkedParent?.grid.columns ||\n                    axis.grid.columns ||\n                    []);\n                const parentAxis = columnIndex ? axis.linkedParent : axis;\n                let thisIndex = -1, lastIndex = 0;\n                // On the left side, when we have columns (not only multiple axes), the\n                // main axis is to the left\n                if (axis.side === 3 && !chart.inverted && columns.length) {\n                    return !axis.linkedParent;\n                }\n                (chart[axis.coll] || []).forEach((otherAxis, index) => {\n                    if (otherAxis.side === axis.side &&\n                        !otherAxis.options.isInternal) {\n                        lastIndex = index;\n                        if (otherAxis === parentAxis) {\n                            // Get the index of the axis in question\n                            thisIndex = index;\n                        }\n                    }\n                });\n                return (lastIndex === thisIndex &&\n                    (isNumber(columnIndex) ?\n                        columns.length === columnIndex :\n                        true));\n            }\n            /**\n             * Add extra border based on the provided path.\n             * @private\n             * @param {SVGPath} path\n             * The path of the border.\n             * @return {Highcharts.SVGElement}\n             * Border\n             */\n            renderBorder(path) {\n                const axis = this.axis, renderer = axis.chart.renderer, options = axis.options, extraBorderLine = renderer.path(path)\n                    .addClass('highcharts-axis-line')\n                    .add(axis.axisGroup);\n                if (!renderer.styledMode) {\n                    extraBorderLine.attr({\n                        stroke: options.lineColor,\n                        'stroke-width': options.lineWidth,\n                        zIndex: 7\n                    });\n                }\n                return extraBorderLine;\n            }\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        // First letter of the day of the week, e.g. 'M' for 'Monday'.\n        dateFormats.E = function (timestamp) {\n            return this.dateFormat('%a', timestamp, true).charAt(0);\n        };\n        // Adds week date format\n        dateFormats.W = function (timestamp) {\n            const time = this, d = new this.Date(timestamp), unitsToOmit = ['Hours', 'Milliseconds', 'Minutes', 'Seconds'];\n            unitsToOmit.forEach(function (format) {\n                time.set(format, d, 0);\n            });\n            const firstDay = (this.get('Day', d) + 6) % 7;\n            const thursday = new this.Date(d.valueOf());\n            this.set('Date', thursday, this.get('Date', d) - firstDay + 3);\n            const firstThursday = new this.Date(this.get('FullYear', thursday), 0, 1);\n            if (this.get('Day', firstThursday) !== 4) {\n                this.set('Month', d, 0);\n                this.set('Date', d, 1 + (11 - this.get('Day', firstThursday)) % 7);\n            }\n            return (1 +\n                Math.floor((thursday.valueOf() - firstThursday.valueOf()) / 604800000)).toString();\n        };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const GridAxis = {\n            compose\n        };\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * @productdesc {gantt}\n         * For grid axes (like in Gantt charts),\n         * it is possible to declare as a list to provide different\n         * formats depending on available space.\n         *\n         * Defaults to:\n         * ```js\n         * {\n         *     hour: { list: ['%H:%M', '%H'] },\n         *     day: { list: ['%A, %e. %B', '%a, %e. %b', '%E'] },\n         *     week: { list: ['Week %W', 'W%W'] },\n         *     month: { list: ['%B', '%b', '%o'] }\n         * }\n         * ```\n         *\n         * @sample {gantt} gantt/grid-axis/date-time-label-formats\n         *         Gantt chart with custom axis date format.\n         *\n         * @apioption xAxis.dateTimeLabelFormats\n         */\n        /**\n         * Set grid options for the axis labels. Requires Highcharts Gantt.\n         *\n         * @since     6.2.0\n         * @product   gantt\n         * @apioption xAxis.grid\n         */\n        /**\n         * Enable grid on the axis labels. Defaults to true for Gantt charts.\n         *\n         * @type      {boolean}\n         * @default   true\n         * @since     6.2.0\n         * @product   gantt\n         * @apioption xAxis.grid.enabled\n         */\n        /**\n         * Set specific options for each column (or row for horizontal axes) in the\n         * grid. Each extra column/row is its own axis, and the axis options can be set\n         * here.\n         *\n         * @sample gantt/demo/left-axis-table\n         *         Left axis as a table\n         * @sample gantt/demo/treegrid-columns\n         *         Collapsible tree grid with columns\n         *\n         * @type      {Array<Highcharts.XAxisOptions>}\n         * @apioption xAxis.grid.columns\n         */\n        /**\n         * Set border color for the label grid lines.\n         *\n         * @type      {Highcharts.ColorString}\n         * @default   #e6e6e6\n         * @apioption xAxis.grid.borderColor\n         */\n        /**\n         * Set border width of the label grid lines.\n         *\n         * @type      {number}\n         * @default   1\n         * @apioption xAxis.grid.borderWidth\n         */\n        /**\n         * Set cell height for grid axis labels. By default this is calculated from font\n         * size. This option only applies to horizontal axes. For vertical axes, check\n         * the [#yAxis.staticScale](yAxis.staticScale) option.\n         *\n         * @sample gantt/grid-axis/cellheight\n         *         Gant chart with custom cell height\n         * @type      {number}\n         * @apioption xAxis.grid.cellHeight\n         */\n        ''; // keeps doclets above in JS file\n\n        return GridAxis;\n    });\n    _registerModule(_modules, 'Gantt/Tree.js', [_modules['Core/Utilities.js']], function (U) {\n        /* *\n         *\n         *  (c) 2016-2024 Highsoft AS\n         *\n         *  Authors: Jon Arild Nygard\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Imports\n         *\n         * */\n        const { extend, isNumber, pick } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Creates an object map from parent id to childrens index.\n         *\n         * @private\n         * @function Highcharts.Tree#getListOfParents\n         *\n         * @param {Array<*>} data\n         *        List of points set in options. `Array.parent` is parent id of point.\n         *\n         * @param {Array<string>} ids\n         *        List of all point ids.\n         *\n         * @return {Highcharts.Dictionary<Array<*>>}\n         * Map from parent id to children index in data\n         */\n        function getListOfParents(data) {\n            const root = '', ids = [], listOfParents = data.reduce((prev, curr) => {\n                const { parent = '', id } = curr;\n                if (typeof prev[parent] === 'undefined') {\n                    prev[parent] = [];\n                }\n                prev[parent].push(curr);\n                if (id) {\n                    ids.push(id);\n                }\n                return prev;\n            }, {});\n            Object.keys(listOfParents).forEach((node) => {\n                if ((node !== root) && (ids.indexOf(node) === -1)) {\n                    const adoptedByRoot = listOfParents[node].map(function (orphan) {\n                        const { parent, ...parentExcluded } = orphan; // #15196\n                        return parentExcluded;\n                    });\n                    listOfParents[root].push(...adoptedByRoot);\n                    delete listOfParents[node];\n                }\n            });\n            return listOfParents;\n        }\n        /** @private */\n        function getNode(id, parent, level, data, mapOfIdToChildren, options) {\n            const after = options && options.after, before = options && options.before, node = {\n                data,\n                depth: level - 1,\n                id,\n                level,\n                parent: (parent || '')\n            };\n            let descendants = 0, height = 0, start, end;\n            // Allow custom logic before the children has been created.\n            if (typeof before === 'function') {\n                before(node, options);\n            }\n            // Call getNode recursively on the children. Calulate the height of the\n            // node, and the number of descendants.\n            const children = ((mapOfIdToChildren[id] || [])).map((child) => {\n                const node = getNode(child.id, id, (level + 1), child, mapOfIdToChildren, options), childStart = child.start || NaN, childEnd = (child.milestone === true ?\n                    childStart :\n                    child.end ||\n                        NaN);\n                // Start should be the lowest child.start.\n                start = ((!isNumber(start) || childStart < start) ?\n                    childStart :\n                    start);\n                // End should be the largest child.end.\n                // If child is milestone, then use start as end.\n                end = ((!isNumber(end) || childEnd > end) ?\n                    childEnd :\n                    end);\n                descendants = descendants + 1 + node.descendants;\n                height = Math.max(node.height + 1, height);\n                return node;\n            });\n            // Calculate start and end for point if it is not already explicitly set.\n            if (data) {\n                data.start = pick(data.start, start);\n                data.end = pick(data.end, end);\n            }\n            extend(node, {\n                children: children,\n                descendants: descendants,\n                height: height\n            });\n            // Allow custom logic after the children has been created.\n            if (typeof after === 'function') {\n                after(node, options);\n            }\n            return node;\n        }\n        /** @private */\n        function getTree(data, options) {\n            return getNode('', null, 1, null, getListOfParents(data), options);\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const Tree = {\n            getNode,\n            getTree\n        };\n\n        return Tree;\n    });\n    _registerModule(_modules, 'Core/Axis/TreeGrid/TreeGridTick.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (H, U) {\n        /* *\n         *\n         *  (c) 2016 Highsoft AS\n         *  Authors: Jon Arild Nygard\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { composed } = H;\n        const { addEvent, removeEvent, isObject, isNumber, pick, pushUnique, wrap } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * @private\n         */\n        function onTickInit() {\n            const tick = this;\n            if (!tick.treeGrid) {\n                tick.treeGrid = new TreeGridTickAdditions(tick);\n            }\n        }\n        /**\n         * @private\n         */\n        function onTickHover(label) {\n            label.addClass('highcharts-treegrid-node-active');\n            if (!label.renderer.styledMode) {\n                label.css({\n                    textDecoration: 'underline'\n                });\n            }\n        }\n        /**\n         * @private\n         */\n        function onTickHoverExit(label, options) {\n            const css = isObject(options.style) ? options.style : {};\n            label.removeClass('highcharts-treegrid-node-active');\n            if (!label.renderer.styledMode) {\n                label.css({ textDecoration: (css.textDecoration || 'none') });\n            }\n        }\n        /**\n         * @private\n         */\n        function renderLabelIcon(tick, params) {\n            const treeGrid = tick.treeGrid, isNew = !treeGrid.labelIcon, renderer = params.renderer, labelBox = params.xy, options = params.options, width = options.width || 0, height = options.height || 0, padding = options.padding ?? tick.axis.linkedParent ? 0 : 5, iconCenter = {\n                x: labelBox.x - (width / 2) - padding,\n                y: labelBox.y - (height / 2)\n            }, rotation = params.collapsed ? 90 : 180, shouldRender = params.show && isNumber(iconCenter.y);\n            let icon = treeGrid.labelIcon;\n            if (!icon) {\n                treeGrid.labelIcon = icon = renderer\n                    .path(renderer.symbols[options.type](options.x || 0, options.y || 0, width, height))\n                    .addClass('highcharts-label-icon')\n                    .add(params.group);\n            }\n            // Set the new position, and show or hide\n            icon[shouldRender ? 'show' : 'hide'](); // #14904, #1338\n            // Presentational attributes\n            if (!renderer.styledMode) {\n                icon\n                    .attr({\n                    cursor: 'pointer',\n                    'fill': pick(params.color, \"#666666\" /* Palette.neutralColor60 */),\n                    'stroke-width': 1,\n                    stroke: options.lineColor,\n                    strokeWidth: options.lineWidth || 0\n                });\n            }\n            // Update the icon positions\n            icon[isNew ? 'attr' : 'animate']({\n                translateX: iconCenter.x,\n                translateY: iconCenter.y,\n                rotation: rotation\n            });\n        }\n        /**\n         * @private\n         */\n        function wrapGetLabelPosition(proceed, x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {\n            const tick = this, lbOptions = pick(tick.options && tick.options.labels, labelOptions), pos = tick.pos, axis = tick.axis, options = axis.options, isTreeGrid = options.type === 'treegrid', result = proceed.apply(tick, [x, y, label, horiz, lbOptions, tickmarkOffset, index, step]);\n            let mapOfPosToGridNode, node, level;\n            if (isTreeGrid) {\n                const { width = 0, padding = axis.linkedParent ? 0 : 5 } = (lbOptions && isObject(lbOptions.symbol, true) ?\n                    lbOptions.symbol :\n                    {}), indentation = (lbOptions && isNumber(lbOptions.indentation) ?\n                    lbOptions.indentation :\n                    0);\n                mapOfPosToGridNode = axis.treeGrid.mapOfPosToGridNode;\n                node = mapOfPosToGridNode && mapOfPosToGridNode[pos];\n                level = (node && node.depth) || 1;\n                result.x += (\n                // Add space for symbols\n                (width + (padding * 2)) +\n                    // Apply indentation\n                    ((level - 1) * indentation));\n            }\n            return result;\n        }\n        /**\n         * @private\n         */\n        function wrapRenderLabel(proceed) {\n            const tick = this, { pos, axis, label, treeGrid: tickGrid, options: tickOptions } = tick, icon = tickGrid?.labelIcon, labelElement = label?.element, { treeGrid: axisGrid, options: axisOptions, chart, tickPositions } = axis, mapOfPosToGridNode = axisGrid.mapOfPosToGridNode, labelOptions = pick(tickOptions?.labels, axisOptions?.labels), symbolOptions = (labelOptions && isObject(labelOptions.symbol, true) ?\n                labelOptions.symbol :\n                {}), node = mapOfPosToGridNode && mapOfPosToGridNode[pos], { descendants, depth } = node || {}, hasDescendants = node && descendants && descendants > 0, level = depth, isTreeGridElement = (axisOptions.type === 'treegrid') && labelElement, shouldRender = tickPositions.indexOf(pos) > -1, prefixClassName = 'highcharts-treegrid-node-', prefixLevelClass = prefixClassName + 'level-', styledMode = chart.styledMode;\n            let collapsed, addClassName, removeClassName;\n            if (isTreeGridElement && node) {\n                // Add class name for hierarchical styling.\n                label\n                    .removeClass(new RegExp(prefixLevelClass + '.*'))\n                    .addClass(prefixLevelClass + level);\n            }\n            proceed.apply(tick, Array.prototype.slice.call(arguments, 1));\n            if (isTreeGridElement && hasDescendants) {\n                collapsed = axisGrid.isCollapsed(node);\n                renderLabelIcon(tick, {\n                    color: (!styledMode &&\n                        label.styles &&\n                        label.styles.color ||\n                        ''),\n                    collapsed: collapsed,\n                    group: label.parentGroup,\n                    options: symbolOptions,\n                    renderer: label.renderer,\n                    show: shouldRender,\n                    xy: label.xy\n                });\n                // Add class name for the node.\n                addClassName = prefixClassName +\n                    (collapsed ? 'collapsed' : 'expanded');\n                removeClassName = prefixClassName +\n                    (collapsed ? 'expanded' : 'collapsed');\n                label\n                    .addClass(addClassName)\n                    .removeClass(removeClassName);\n                if (!styledMode) {\n                    label.css({\n                        cursor: 'pointer'\n                    });\n                }\n                // Add events to both label text and icon\n                [label, icon].forEach((object) => {\n                    if (object && !object.attachedTreeGridEvents) {\n                        // On hover\n                        addEvent(object.element, 'mouseover', function () {\n                            onTickHover(label);\n                        });\n                        // On hover out\n                        addEvent(object.element, 'mouseout', function () {\n                            onTickHoverExit(label, labelOptions);\n                        });\n                        addEvent(object.element, 'click', function () {\n                            tickGrid.toggleCollapse();\n                        });\n                        object.attachedTreeGridEvents = true;\n                    }\n                });\n            }\n            else if (icon) {\n                removeEvent(labelElement);\n                label?.css({ cursor: 'default' });\n                icon.destroy();\n            }\n        }\n        /* *\n         *\n         *  Classes\n         *\n         * */\n        /**\n         * @private\n         * @class\n         */\n        class TreeGridTickAdditions {\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            /**\n             * @private\n             */\n            static compose(TickClass) {\n                if (pushUnique(composed, this.compose)) {\n                    const tickProto = TickClass.prototype;\n                    addEvent(TickClass, 'init', onTickInit);\n                    wrap(tickProto, 'getLabelPosition', wrapGetLabelPosition);\n                    wrap(tickProto, 'renderLabel', wrapRenderLabel);\n                    // backwards compatibility\n                    tickProto.collapse = function (redraw) {\n                        this.treeGrid.collapse(redraw);\n                    };\n                    tickProto.expand = function (redraw) {\n                        this.treeGrid.expand(redraw);\n                    };\n                    tickProto.toggleCollapse = function (redraw) {\n                        this.treeGrid.toggleCollapse(redraw);\n                    };\n                }\n            }\n            /* *\n             *\n             *  Constructors\n             *\n             * */\n            /**\n             * @private\n             */\n            constructor(tick) {\n                this.tick = tick;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Collapse the grid cell. Used when axis is of type treegrid.\n             *\n             * @see gantt/treegrid-axis/collapsed-dynamically/demo.js\n             *\n             * @private\n             * @function Highcharts.Tick#collapse\n             *\n             * @param {boolean} [redraw=true]\n             * Whether to redraw the chart or wait for an explicit call to\n             * {@link Highcharts.Chart#redraw}\n             */\n            collapse(redraw) {\n                const tick = this.tick, axis = tick.axis, brokenAxis = axis.brokenAxis;\n                if (brokenAxis &&\n                    axis.treeGrid.mapOfPosToGridNode) {\n                    const pos = tick.pos, node = axis.treeGrid.mapOfPosToGridNode[pos], breaks = axis.treeGrid.collapse(node);\n                    brokenAxis.setBreaks(breaks, pick(redraw, true));\n                }\n            }\n            /**\n             * Destroy remaining labelIcon if exist.\n             *\n             * @private\n             * @function Highcharts.Tick#destroy\n             */\n            destroy() {\n                if (this.labelIcon) {\n                    this.labelIcon.destroy();\n                }\n            }\n            /**\n             * Expand the grid cell. Used when axis is of type treegrid.\n             *\n             * @see gantt/treegrid-axis/collapsed-dynamically/demo.js\n             *\n             * @private\n             * @function Highcharts.Tick#expand\n             *\n             * @param {boolean} [redraw=true]\n             * Whether to redraw the chart or wait for an explicit call to\n             * {@link Highcharts.Chart#redraw}\n             */\n            expand(redraw) {\n                const { pos, axis } = this.tick, { treeGrid, brokenAxis } = axis, posMappedNodes = treeGrid.mapOfPosToGridNode;\n                if (brokenAxis && posMappedNodes) {\n                    const node = posMappedNodes[pos], breaks = treeGrid.expand(node);\n                    brokenAxis.setBreaks(breaks, pick(redraw, true));\n                }\n            }\n            /**\n             * Toggle the collapse/expand state of the grid cell. Used when axis is\n             * of type treegrid.\n             *\n             * @see gantt/treegrid-axis/collapsed-dynamically/demo.js\n             *\n             * @private\n             * @function Highcharts.Tick#toggleCollapse\n             *\n             * @param {boolean} [redraw=true]\n             * Whether to redraw the chart or wait for an explicit call to\n             * {@link Highcharts.Chart#redraw}\n             */\n            toggleCollapse(redraw) {\n                const tick = this.tick, axis = tick.axis, brokenAxis = axis.brokenAxis;\n                if (brokenAxis &&\n                    axis.treeGrid.mapOfPosToGridNode) {\n                    const pos = tick.pos, node = axis.treeGrid.mapOfPosToGridNode[pos], breaks = axis.treeGrid.toggleCollapse(node);\n                    brokenAxis.setBreaks(breaks, pick(redraw, true));\n                }\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return TreeGridTickAdditions;\n    });\n    _registerModule(_modules, 'Series/TreeUtilities.js', [_modules['Core/Color/Color.js'], _modules['Core/Utilities.js']], function (Color, U) {\n        /* *\n         *\n         *  (c) 2014-2024 Highsoft AS\n         *\n         *  Authors: Jon Arild Nygard / Oystein Moseng\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { extend, isArray, isNumber, isObject, merge, pick } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /* eslint-disable valid-jsdoc */\n        /**\n         * @private\n         */\n        function getColor(node, options) {\n            const index = options.index, mapOptionsToLevel = options.mapOptionsToLevel, parentColor = options.parentColor, parentColorIndex = options.parentColorIndex, series = options.series, colors = options.colors, siblings = options.siblings, points = series.points, chartOptionsChart = series.chart.options.chart;\n            let getColorByPoint, point, level, colorByPoint, colorIndexByPoint, color, colorIndex;\n            /**\n             * @private\n             */\n            const variateColor = (color) => {\n                const colorVariation = level && level.colorVariation;\n                if (colorVariation &&\n                    colorVariation.key === 'brightness' &&\n                    index &&\n                    siblings) {\n                    return Color.parse(color).brighten(colorVariation.to * (index / siblings)).get();\n                }\n                return color;\n            };\n            if (node) {\n                point = points[node.i];\n                level = mapOptionsToLevel[node.level] || {};\n                getColorByPoint = point && level.colorByPoint;\n                if (getColorByPoint) {\n                    colorIndexByPoint = point.index % (colors ?\n                        colors.length :\n                        chartOptionsChart.colorCount);\n                    colorByPoint = colors && colors[colorIndexByPoint];\n                }\n                // Select either point color, level color or inherited color.\n                if (!series.chart.styledMode) {\n                    color = pick(point && point.options.color, level && level.color, colorByPoint, parentColor && variateColor(parentColor), series.color);\n                }\n                colorIndex = pick(point && point.options.colorIndex, level && level.colorIndex, colorIndexByPoint, parentColorIndex, options.colorIndex);\n            }\n            return {\n                color: color,\n                colorIndex: colorIndex\n            };\n        }\n        /**\n         * Creates a map from level number to its given options.\n         *\n         * @private\n         *\n         * @param {Object} params\n         * Object containing parameters.\n         * - `defaults` Object containing default options. The default options are\n         *   merged with the userOptions to get the final options for a specific\n         *   level.\n         * - `from` The lowest level number.\n         * - `levels` User options from series.levels.\n         * - `to` The highest level number.\n         *\n         * @return {Highcharts.Dictionary<object>|null}\n         * Returns a map from level number to its given options.\n         */\n        function getLevelOptions(params) {\n            let result = {}, defaults, converted, i, from, to, levels;\n            if (isObject(params)) {\n                from = isNumber(params.from) ? params.from : 1;\n                levels = params.levels;\n                converted = {};\n                defaults = isObject(params.defaults) ? params.defaults : {};\n                if (isArray(levels)) {\n                    converted = levels.reduce((obj, item) => {\n                        let level, levelIsConstant, options;\n                        if (isObject(item) && isNumber(item.level)) {\n                            options = merge({}, item);\n                            levelIsConstant = pick(options.levelIsConstant, defaults.levelIsConstant);\n                            // Delete redundant properties.\n                            delete options.levelIsConstant;\n                            delete options.level;\n                            // Calculate which level these options apply to.\n                            level = item.level + (levelIsConstant ? 0 : from - 1);\n                            if (isObject(obj[level])) {\n                                merge(true, obj[level], options); // #16329\n                            }\n                            else {\n                                obj[level] = options;\n                            }\n                        }\n                        return obj;\n                    }, {});\n                }\n                to = isNumber(params.to) ? params.to : 1;\n                for (i = 0; i <= to; i++) {\n                    result[i] = merge({}, defaults, isObject(converted[i]) ? converted[i] : {});\n                }\n            }\n            return result;\n        }\n        /**\n         * @private\n         * @todo Combine buildTree and buildNode with setTreeValues\n         * @todo Remove logic from Treemap and make it utilize this mixin.\n         */\n        function setTreeValues(tree, options) {\n            const before = options.before, idRoot = options.idRoot, mapIdToNode = options.mapIdToNode, nodeRoot = mapIdToNode[idRoot], levelIsConstant = (options.levelIsConstant !== false), points = options.points, point = points[tree.i], optionsPoint = point && point.options || {}, children = [];\n            let childrenTotal = 0;\n            tree.levelDynamic = tree.level - (levelIsConstant ? 0 : nodeRoot.level);\n            tree.name = pick(point && point.name, '');\n            tree.visible = (idRoot === tree.id ||\n                options.visible === true);\n            if (typeof before === 'function') {\n                tree = before(tree, options);\n            }\n            // First give the children some values\n            tree.children.forEach((child, i) => {\n                const newOptions = extend({}, options);\n                extend(newOptions, {\n                    index: i,\n                    siblings: tree.children.length,\n                    visible: tree.visible\n                });\n                child = setTreeValues(child, newOptions);\n                children.push(child);\n                if (child.visible) {\n                    childrenTotal += child.val;\n                }\n            });\n            // Set the values\n            const value = pick(optionsPoint.value, childrenTotal);\n            tree.visible = value >= 0 && (childrenTotal > 0 || tree.visible);\n            tree.children = children;\n            tree.childrenTotal = childrenTotal;\n            tree.isLeaf = tree.visible && !childrenTotal;\n            tree.val = value;\n            return tree;\n        }\n        /**\n         * Update the rootId property on the series. Also makes sure that it is\n         * accessible to exporting.\n         *\n         * @private\n         *\n         * @param {Object} series\n         * The series to operate on.\n         *\n         * @return {string}\n         * Returns the resulting rootId after update.\n         */\n        function updateRootId(series) {\n            let rootId, options;\n            if (isObject(series)) {\n                // Get the series options.\n                options = isObject(series.options) ? series.options : {};\n                // Calculate the rootId.\n                rootId = pick(series.rootNode, options.rootId, '');\n                // Set rootId on series.userOptions to pick it up in exporting.\n                if (isObject(series.userOptions)) {\n                    series.userOptions.rootId = rootId;\n                }\n                // Set rootId on series to pick it up on next update.\n                series.rootNode = rootId;\n            }\n            return rootId;\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const TreeUtilities = {\n            getColor,\n            getLevelOptions,\n            setTreeValues,\n            updateRootId\n        };\n\n        return TreeUtilities;\n    });\n    _registerModule(_modules, 'Core/Axis/TreeGrid/TreeGridAxis.js', [_modules['Core/Axis/BrokenAxis.js'], _modules['Core/Axis/GridAxis.js'], _modules['Core/Globals.js'], _modules['Gantt/Tree.js'], _modules['Core/Axis/TreeGrid/TreeGridTick.js'], _modules['Series/TreeUtilities.js'], _modules['Core/Utilities.js']], function (BrokenAxis, GridAxis, H, Tree, TreeGridTick, TU, U) {\n        /* *\n         *\n         *  (c) 2016 Highsoft AS\n         *  Authors: Jon Arild Nygard\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { composed } = H;\n        const { getLevelOptions } = TU;\n        const { addEvent, find, fireEvent, isArray, isObject, isString, merge, pick, pushUnique, removeEvent, wrap } = U;\n        /* *\n         *\n         *  Variables\n         *\n         * */\n        let TickConstructor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * @private\n         */\n        function getBreakFromNode(node, max) {\n            const to = node.collapseEnd || 0;\n            let from = node.collapseStart || 0;\n            // In broken-axis, the axis.max is minimized until it is not within a\n            // break. Therefore, if break.to is larger than axis.max, the axis.to\n            // should not add the 0.5 axis.tickMarkOffset, to avoid adding a break\n            // larger than axis.max.\n            // TODO consider simplifying broken-axis and this might solve itself\n            if (to >= max) {\n                from -= 0.5;\n            }\n            return {\n                from: from,\n                to: to,\n                showPoints: false\n            };\n        }\n        /**\n         * Creates a tree structure of the data, and the treegrid. Calculates\n         * categories, and y-values of points based on the tree.\n         *\n         * @private\n         * @function getTreeGridFromData\n         *\n         * @param {Array<Highcharts.GanttPointOptions>} data\n         * All the data points to display in the axis.\n         *\n         * @param {boolean} uniqueNames\n         * Whether or not the data node with the same name should share grid cell. If\n         * true they do share cell. False by default.\n         *\n         * @param {number} numberOfSeries\n         *\n         * @return {Object}\n         * Returns an object containing categories, mapOfIdToNode,\n         * mapOfPosToGridNode, and tree.\n         *\n         * @todo There should be only one point per line.\n         * @todo It should be optional to have one category per point, or merge\n         *       cells\n         * @todo Add unit-tests.\n         */\n        function getTreeGridFromData(data, uniqueNames, numberOfSeries) {\n            const categories = [], collapsedNodes = [], mapOfIdToNode = {}, uniqueNamesEnabled = typeof uniqueNames === 'boolean' ?\n                uniqueNames : false;\n            let mapOfPosToGridNode = {}, posIterator = -1;\n            // Build the tree from the series data.\n            const treeParams = {\n                // After the children has been created.\n                after: function (node) {\n                    const gridNode = mapOfPosToGridNode[node.pos];\n                    let height = 0, descendants = 0;\n                    gridNode.children.forEach(function (child) {\n                        descendants += (child.descendants || 0) + 1;\n                        height = Math.max((child.height || 0) + 1, height);\n                    });\n                    gridNode.descendants = descendants;\n                    gridNode.height = height;\n                    if (gridNode.collapsed) {\n                        collapsedNodes.push(gridNode);\n                    }\n                },\n                // Before the children has been created.\n                before: function (node) {\n                    const data = isObject(node.data, true) ?\n                        node.data :\n                        {}, name = isString(data.name) ? data.name : '', parentNode = mapOfIdToNode[node.parent], parentGridNode = (isObject(parentNode, true) ?\n                        mapOfPosToGridNode[parentNode.pos] :\n                        null), hasSameName = function (x) {\n                        return x.name === name;\n                    };\n                    let gridNode, pos;\n                    // If not unique names, look for sibling node with the same name\n                    if (uniqueNamesEnabled &&\n                        isObject(parentGridNode, true) &&\n                        !!(gridNode = find(parentGridNode.children, hasSameName))) {\n                        // If there is a gridNode with the same name, reuse position\n                        pos = gridNode.pos;\n                        // Add data node to list of nodes in the grid node.\n                        gridNode.nodes.push(node);\n                    }\n                    else {\n                        // If it is a new grid node, increment position.\n                        pos = posIterator++;\n                    }\n                    // Add new grid node to map.\n                    if (!mapOfPosToGridNode[pos]) {\n                        mapOfPosToGridNode[pos] = gridNode = {\n                            depth: parentGridNode ? parentGridNode.depth + 1 : 0,\n                            name: name,\n                            id: data.id,\n                            nodes: [node],\n                            children: [],\n                            pos: pos\n                        };\n                        // If not root, then add name to categories.\n                        if (pos !== -1) {\n                            categories.push(name);\n                        }\n                        // Add name to list of children.\n                        if (isObject(parentGridNode, true)) {\n                            parentGridNode.children.push(gridNode);\n                        }\n                    }\n                    // Add data node to map\n                    if (isString(node.id)) {\n                        mapOfIdToNode[node.id] = node;\n                    }\n                    // If one of the points are collapsed, then start the grid node\n                    // in collapsed state.\n                    if (gridNode &&\n                        data.collapsed === true) {\n                        gridNode.collapsed = true;\n                    }\n                    // Assign pos to data node\n                    node.pos = pos;\n                }\n            };\n            const updateYValuesAndTickPos = function (map, numberOfSeries) {\n                const setValues = function (gridNode, start, result) {\n                    const nodes = gridNode.nodes, padding = 0.5;\n                    let end = start + (start === -1 ? 0 : numberOfSeries - 1);\n                    const diff = (end - start) / 2, pos = start + diff;\n                    nodes.forEach(function (node) {\n                        const data = node.data;\n                        if (isObject(data, true)) {\n                            // Update point\n                            data.y = start + (data.seriesIndex || 0);\n                            // Remove the property once used\n                            delete data.seriesIndex;\n                        }\n                        node.pos = pos;\n                    });\n                    result[pos] = gridNode;\n                    gridNode.pos = pos;\n                    gridNode.tickmarkOffset = diff + padding;\n                    gridNode.collapseStart = end + padding;\n                    gridNode.children.forEach(function (child) {\n                        setValues(child, end + 1, result);\n                        end = (child.collapseEnd || 0) - padding;\n                    });\n                    // Set collapseEnd to the end of the last child node.\n                    gridNode.collapseEnd = end + padding;\n                    return result;\n                };\n                return setValues(map['-1'], -1, {});\n            };\n            // Create tree from data\n            const tree = Tree.getTree(data, treeParams);\n            // Update y values of data, and set calculate tick positions.\n            mapOfPosToGridNode = updateYValuesAndTickPos(mapOfPosToGridNode, numberOfSeries);\n            // Return the resulting data.\n            return {\n                categories: categories,\n                mapOfIdToNode: mapOfIdToNode,\n                mapOfPosToGridNode: mapOfPosToGridNode,\n                collapsedNodes: collapsedNodes,\n                tree: tree\n            };\n        }\n        /**\n         * Builds the tree of categories and calculates its positions.\n         * @private\n         * @param {Object} e Event object\n         * @param {Object} e.target The chart instance which the event was fired on.\n         * @param {object[]} e.target.axes The axes of the chart.\n         */\n        function onBeforeRender(e) {\n            const chart = e.target, axes = chart.axes;\n            axes.filter(function (axis) {\n                return axis.options.type === 'treegrid';\n            }).forEach(function (axis) {\n                const options = axis.options || {}, labelOptions = options.labels, uniqueNames = options.uniqueNames, max = options.max, \n                // Check whether any of series is rendering for the first\n                // time, visibility has changed, or its data is dirty, and\n                // only then update. #10570, #10580. Also check if\n                // mapOfPosToGridNode exists. #10887\n                isDirty = (!axis.treeGrid.mapOfPosToGridNode ||\n                    axis.series.some(function (series) {\n                        return !series.hasRendered ||\n                            series.isDirtyData ||\n                            series.isDirty;\n                    }));\n                let numberOfSeries = 0, data, treeGrid;\n                if (isDirty) {\n                    // Concatenate data from all series assigned to this axis.\n                    data = axis.series.reduce(function (arr, s) {\n                        if (s.visible) {\n                            // Push all data to array\n                            (s.options.data || []).forEach(function (data) {\n                                // For using keys - rebuild the data structure\n                                if (s.options.keys && s.options.keys.length) {\n                                    data = s.pointClass.prototype\n                                        .optionsToObject\n                                        .call({ series: s }, data);\n                                    s.pointClass.setGanttPointAliases(data);\n                                }\n                                if (isObject(data, true)) {\n                                    // Set series index on data. Removed again\n                                    // after use.\n                                    data.seriesIndex = (numberOfSeries);\n                                    arr.push(data);\n                                }\n                            });\n                            // Increment series index\n                            if (uniqueNames === true) {\n                                numberOfSeries++;\n                            }\n                        }\n                        return arr;\n                    }, []);\n                    // If max is higher than set data - add a\n                    // dummy data to render categories #10779\n                    if (max && data.length < max) {\n                        for (let i = data.length; i <= max; i++) {\n                            data.push({\n                                // Use the zero-width character\n                                // to avoid conflict with uniqueNames\n                                name: i + '\\u200B'\n                            });\n                        }\n                    }\n                    // setScale is fired after all the series is initialized,\n                    // which is an ideal time to update the axis.categories.\n                    treeGrid = getTreeGridFromData(data, uniqueNames || false, (uniqueNames === true) ? numberOfSeries : 1);\n                    // Assign values to the axis.\n                    axis.categories = treeGrid.categories;\n                    axis.treeGrid.mapOfPosToGridNode = (treeGrid.mapOfPosToGridNode);\n                    axis.hasNames = true;\n                    axis.treeGrid.tree = treeGrid.tree;\n                    // Update yData now that we have calculated the y values\n                    axis.series.forEach(function (series) {\n                        const axisData = (series.options.data || []).map(function (d) {\n                            if (isArray(d) &&\n                                series.options.keys &&\n                                series.options.keys.length) {\n                                // Get the axisData from the data array used to\n                                // build the treeGrid where has been modified\n                                data.forEach(function (point) {\n                                    if (d.indexOf(point.x) >= 0 &&\n                                        d.indexOf(point.x2) >= 0) {\n                                        d = point;\n                                    }\n                                });\n                            }\n                            return isObject(d, true) ? merge(d) : d;\n                        });\n                        // Avoid destroying points when series is not visible\n                        if (series.visible) {\n                            series.setData(axisData, false);\n                        }\n                    });\n                    // Calculate the label options for each level in the tree.\n                    axis.treeGrid.mapOptionsToLevel =\n                        getLevelOptions({\n                            defaults: labelOptions,\n                            from: 1,\n                            levels: labelOptions && labelOptions.levels,\n                            to: axis.treeGrid.tree && axis.treeGrid.tree.height\n                        });\n                    // Setting initial collapsed nodes\n                    if (e.type === 'beforeRender') {\n                        axis.treeGrid.collapsedNodes = treeGrid.collapsedNodes;\n                    }\n                }\n            });\n        }\n        /**\n         * Generates a tick for initial positioning.\n         *\n         * @private\n         * @function Highcharts.GridAxis#generateTick\n         *\n         * @param {Function} proceed\n         * The original generateTick function.\n         *\n         * @param {number} pos\n         * The tick position in axis values.\n         */\n        function wrapGenerateTick(proceed, pos) {\n            const axis = this, mapOptionsToLevel = axis.treeGrid.mapOptionsToLevel || {}, isTreeGrid = axis.options.type === 'treegrid', ticks = axis.ticks;\n            let tick = ticks[pos], levelOptions, options, gridNode;\n            if (isTreeGrid &&\n                axis.treeGrid.mapOfPosToGridNode) {\n                gridNode = axis.treeGrid.mapOfPosToGridNode[pos];\n                levelOptions = mapOptionsToLevel[gridNode.depth];\n                if (levelOptions) {\n                    options = {\n                        labels: levelOptions\n                    };\n                }\n                if (!tick &&\n                    TickConstructor) {\n                    ticks[pos] = tick =\n                        new TickConstructor(axis, pos, void 0, void 0, {\n                            category: gridNode.name,\n                            tickmarkOffset: gridNode.tickmarkOffset,\n                            options: options\n                        });\n                }\n                else {\n                    // update labels depending on tick interval\n                    tick.parameters.category = gridNode.name;\n                    tick.options = options;\n                    tick.addLabel();\n                }\n            }\n            else {\n                proceed.apply(axis, Array.prototype.slice.call(arguments, 1));\n            }\n        }\n        /**\n         * @private\n         */\n        function wrapInit(proceed, chart, userOptions, coll) {\n            const axis = this, isTreeGrid = userOptions.type === 'treegrid';\n            if (!axis.treeGrid) {\n                axis.treeGrid = new TreeGridAxisAdditions(axis);\n            }\n            // Set default and forced options for TreeGrid\n            if (isTreeGrid) {\n                // Add event for updating the categories of a treegrid.\n                // NOTE Preferably these events should be set on the axis.\n                addEvent(chart, 'beforeRender', onBeforeRender);\n                addEvent(chart, 'beforeRedraw', onBeforeRender);\n                // Add new collapsed nodes on addseries\n                addEvent(chart, 'addSeries', function (e) {\n                    if (e.options.data) {\n                        const treeGrid = getTreeGridFromData(e.options.data, userOptions.uniqueNames || false, 1);\n                        axis.treeGrid.collapsedNodes = (axis.treeGrid.collapsedNodes || []).concat(treeGrid.collapsedNodes);\n                    }\n                });\n                // Collapse all nodes in axis.treegrid.collapsednodes\n                // where collapsed equals true.\n                addEvent(axis, 'foundExtremes', function () {\n                    if (axis.treeGrid.collapsedNodes) {\n                        axis.treeGrid.collapsedNodes.forEach(function (node) {\n                            const breaks = axis.treeGrid.collapse(node);\n                            if (axis.brokenAxis) {\n                                axis.brokenAxis.setBreaks(breaks, false);\n                                // remove the node from the axis collapsedNodes\n                                if (axis.treeGrid.collapsedNodes) {\n                                    axis.treeGrid.collapsedNodes = axis.treeGrid\n                                        .collapsedNodes\n                                        .filter((n) => ((node.collapseStart !==\n                                        n.collapseStart) ||\n                                        node.collapseEnd !== n.collapseEnd));\n                                }\n                            }\n                        });\n                    }\n                });\n                // If staticScale is not defined on the yAxis\n                // and chart height is set, set axis.isDirty\n                // to ensure collapsing works (#12012)\n                addEvent(axis, 'afterBreaks', function () {\n                    if (axis.coll === 'yAxis' &&\n                        !axis.staticScale &&\n                        axis.chart.options.chart.height) {\n                        axis.isDirty = true;\n                    }\n                });\n                userOptions = merge({\n                    // Default options\n                    grid: {\n                        enabled: true\n                    },\n                    // TODO: add support for align in treegrid.\n                    labels: {\n                        align: 'left',\n                        /**\n                        * Set options on specific levels in a tree grid axis. Takes\n                        * precedence over labels options.\n                        *\n                        * @sample {gantt} gantt/treegrid-axis/labels-levels\n                        *         Levels on TreeGrid Labels\n                        *\n                        * @type      {Array<*>}\n                        * @product   gantt\n                        * @apioption yAxis.labels.levels\n                        *\n                        * @private\n                        */\n                        levels: [{\n                                /**\n                                * Specify the level which the options within this object\n                                * applies to.\n                                *\n                                * @type      {number}\n                                * @product   gantt\n                                * @apioption yAxis.labels.levels.level\n                                *\n                                * @private\n                                */\n                                level: void 0\n                            }, {\n                                level: 1,\n                                /**\n                                 * @type      {Highcharts.CSSObject}\n                                 * @product   gantt\n                                 * @apioption yAxis.labels.levels.style\n                                 *\n                                 * @private\n                                 */\n                                style: {\n                                    /** @ignore-option */\n                                    fontWeight: 'bold'\n                                }\n                            }],\n                        /**\n                         * The symbol for the collapse and expand icon in a\n                         * treegrid.\n                         *\n                         * @product      gantt\n                         * @optionparent yAxis.labels.symbol\n                         *\n                         * @private\n                         */\n                        symbol: {\n                            /**\n                             * The symbol type. Points to a definition function in\n                             * the `Highcharts.Renderer.symbols` collection.\n                             *\n                             * @type {Highcharts.SymbolKeyValue}\n                             *\n                             * @private\n                             */\n                            type: 'triangle',\n                            x: -5,\n                            y: -5,\n                            height: 10,\n                            width: 10\n                        }\n                    },\n                    uniqueNames: false\n                }, userOptions, {\n                    // Forced options\n                    reversed: true\n                });\n            }\n            // Now apply the original function with the original arguments, which are\n            // sliced off this function's arguments\n            proceed.apply(axis, [chart, userOptions, coll]);\n            if (isTreeGrid) {\n                axis.hasNames = true;\n                axis.options.showLastLabel = true;\n            }\n        }\n        /**\n         * Set the tick positions, tickInterval, axis min and max.\n         *\n         * @private\n         * @function Highcharts.GridAxis#setTickInterval\n         *\n         * @param {Function} proceed\n         * The original setTickInterval function.\n         */\n        function wrapSetTickInterval(proceed) {\n            const axis = this, options = axis.options, linkedParent = typeof options.linkedTo === 'number' ?\n                this.chart[axis.coll]?.[options.linkedTo] :\n                void 0, isTreeGrid = options.type === 'treegrid';\n            if (isTreeGrid) {\n                axis.min = pick(axis.userMin, options.min, axis.dataMin);\n                axis.max = pick(axis.userMax, options.max, axis.dataMax);\n                fireEvent(axis, 'foundExtremes');\n                // `setAxisTranslation` modifies the min and max according to axis\n                // breaks.\n                axis.setAxisTranslation();\n                axis.tickInterval = 1;\n                axis.tickmarkOffset = 0.5;\n                axis.tickPositions = axis.treeGrid.mapOfPosToGridNode ?\n                    axis.treeGrid.getTickPositions() :\n                    [];\n                if (linkedParent) {\n                    const linkedParentExtremes = linkedParent.getExtremes();\n                    axis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);\n                    axis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);\n                    axis.tickPositions = linkedParent.tickPositions;\n                }\n                axis.linkedParent = linkedParent;\n            }\n            else {\n                proceed.apply(axis, Array.prototype.slice.call(arguments, 1));\n            }\n        }\n        /**\n         * Wrap axis redraw to remove TreeGrid events from ticks\n         *\n         * @private\n         * @function Highcharts.GridAxis#redraw\n         *\n         * @param {Function} proceed\n         * The original setTickInterval function.\n         */\n        function wrapRedraw(proceed) {\n            const axis = this, options = axis.options, isTreeGrid = options.type === 'treegrid';\n            if (isTreeGrid && axis.visible) {\n                axis.tickPositions.forEach(function (pos) {\n                    const tick = axis.ticks[pos];\n                    if (tick.label && tick.label.attachedTreeGridEvents) {\n                        removeEvent(tick.label.element);\n                        tick.label.attachedTreeGridEvents = false;\n                    }\n                });\n            }\n            proceed.apply(axis, Array.prototype.slice.call(arguments, 1));\n        }\n        /* *\n         *\n         *  Classes\n         *\n         * */\n        /**\n         * @private\n         * @class\n         */\n        class TreeGridAxisAdditions {\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            /**\n             * @private\n             */\n            static compose(AxisClass, ChartClass, SeriesClass, TickClass) {\n                if (pushUnique(composed, this.compose)) {\n                    const axisProps = AxisClass.prototype;\n                    if (AxisClass.keepProps.indexOf('treeGrid') === -1) {\n                        AxisClass.keepProps.push('treeGrid');\n                    }\n                    wrap(axisProps, 'generateTick', wrapGenerateTick);\n                    wrap(axisProps, 'init', wrapInit);\n                    wrap(axisProps, 'setTickInterval', wrapSetTickInterval);\n                    wrap(axisProps, 'redraw', wrapRedraw);\n                    // Make utility functions available for testing.\n                    axisProps.utils = {\n                        getNode: Tree.getNode\n                    };\n                    if (!TickConstructor) {\n                        TickConstructor = TickClass;\n                    }\n                }\n                GridAxis.compose(AxisClass, ChartClass, TickClass);\n                BrokenAxis.compose(AxisClass, SeriesClass);\n                TreeGridTick.compose(TickClass);\n                return AxisClass;\n            }\n            /* *\n             *\n             *  Constructors\n             *\n             * */\n            /**\n             * @private\n             */\n            constructor(axis) {\n                this.axis = axis;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Set the collapse status.\n             *\n             * @private\n             *\n             * @param {Highcharts.Axis} axis\n             * The axis to check against.\n             *\n             * @param {Highcharts.GridNode} node\n             * The node to collapse.\n             */\n            setCollapsedStatus(node) {\n                const axis = this.axis, chart = axis.chart;\n                axis.series.forEach(function (series) {\n                    const data = series.options.data;\n                    if (node.id && data) {\n                        const point = chart.get(node.id), dataPoint = data[series.data.indexOf(point)];\n                        if (point && dataPoint) {\n                            point.collapsed = node.collapsed;\n                            dataPoint.collapsed = node.collapsed;\n                        }\n                    }\n                });\n            }\n            /**\n             * Calculates the new axis breaks to collapse a node.\n             *\n             * @private\n             *\n             * @param {Highcharts.Axis} axis\n             * The axis to check against.\n             *\n             * @param {Highcharts.GridNode} node\n             * The node to collapse.\n             *\n             * @param {number} pos\n             * The tick position to collapse.\n             *\n             * @return {Array<object>}\n             * Returns an array of the new breaks for the axis.\n             */\n            collapse(node) {\n                const axis = this.axis, breaks = (axis.options.breaks || []), obj = getBreakFromNode(node, axis.max);\n                breaks.push(obj);\n                // Change the collapsed flag #13838\n                node.collapsed = true;\n                axis.treeGrid.setCollapsedStatus(node);\n                return breaks;\n            }\n            /**\n             * Calculates the new axis breaks to expand a node.\n             *\n             * @private\n             *\n             * @param {Highcharts.Axis} axis\n             * The axis to check against.\n             *\n             * @param {Highcharts.GridNode} node\n             * The node to expand.\n             *\n             * @param {number} pos\n             * The tick position to expand.\n             *\n             * @return {Array<object>}\n             * Returns an array of the new breaks for the axis.\n             */\n            expand(node) {\n                const axis = this.axis, breaks = (axis.options.breaks || []), obj = getBreakFromNode(node, axis.max);\n                // Change the collapsed flag #13838\n                node.collapsed = false;\n                axis.treeGrid.setCollapsedStatus(node);\n                // Remove the break from the axis breaks array.\n                return breaks.reduce(function (arr, b) {\n                    if (b.to !== obj.to || b.from !== obj.from) {\n                        arr.push(b);\n                    }\n                    return arr;\n                }, []);\n            }\n            /**\n             * Creates a list of positions for the ticks on the axis. Filters out\n             * positions that are outside min and max, or is inside an axis break.\n             *\n             * @private\n             *\n             * @return {Array<number>}\n             * List of positions.\n             */\n            getTickPositions() {\n                const axis = this.axis, roundedMin = Math.floor(axis.min / axis.tickInterval) * axis.tickInterval, roundedMax = Math.ceil(axis.max / axis.tickInterval) * axis.tickInterval;\n                return Object.keys(axis.treeGrid.mapOfPosToGridNode || {}).reduce(function (arr, key) {\n                    const pos = +key;\n                    if (pos >= roundedMin &&\n                        pos <= roundedMax &&\n                        !(axis.brokenAxis && axis.brokenAxis.isInAnyBreak(pos))) {\n                        arr.push(pos);\n                    }\n                    return arr;\n                }, []);\n            }\n            /**\n             * Check if a node is collapsed.\n             *\n             * @private\n             *\n             * @param {Highcharts.Axis} axis\n             * The axis to check against.\n             *\n             * @param {Object} node\n             * The node to check if is collapsed.\n             *\n             * @param {number} pos\n             * The tick position to collapse.\n             *\n             * @return {boolean}\n             * Returns true if collapsed, false if expanded.\n             */\n            isCollapsed(node) {\n                const axis = this.axis, breaks = (axis.options.breaks || []), obj = getBreakFromNode(node, axis.max);\n                return breaks.some(function (b) {\n                    return b.from === obj.from && b.to === obj.to;\n                });\n            }\n            /**\n             * Calculates the new axis breaks after toggling the collapse/expand\n             * state of a node. If it is collapsed it will be expanded, and if it is\n             * exapended it will be collapsed.\n             *\n             * @private\n             *\n             * @param {Highcharts.Axis} axis\n             * The axis to check against.\n             *\n             * @param {Highcharts.GridNode} node\n             * The node to toggle.\n             *\n             * @return {Array<object>}\n             * Returns an array of the new breaks for the axis.\n             */\n            toggleCollapse(node) {\n                return (this.isCollapsed(node) ?\n                    this.expand(node) :\n                    this.collapse(node));\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return TreeGridAxisAdditions;\n    });\n    _registerModule(_modules, 'masters/modules/treegrid.src.js', [_modules['Core/Globals.js'], _modules['Core/Axis/TreeGrid/TreeGridAxis.js']], function (Highcharts, TreeGridAxis) {\n\n        const G = Highcharts;\n        // Compositions\n        TreeGridAxis.compose(G.Axis, G.Chart, G.Series, G.Tick);\n\n    });\n}));"],"names":["factory","module","exports","define","amd","Highcharts","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","window","dispatchEvent","detail","H","StackItem","U","BrokenAxis","composed","addEvent","find","fireEvent","isArray","isNumber","pick","pushUnique","onAxisAfterInit","brokenAxis","setBreaks","options","breaks","onAxisAfterSetOptions","axis","hasBreaks","ordinal","onAxisAfterSetTickPositions","tickPositions","info","newPositions","i","length","isInAnyBreak","push","onAxisInit","Additions","onSeriesAfterGeneratePoints","isDirty","connectNulls","points","xAxis","yAxis","point","nullGap","y","isPointInBreak","x","visible","onSeriesAfterRender","drawBreaks","pointArrayMap","seriesDrawBreaks","keys","threshold","series","forEach","key","breakArray","isXAxis","min","breaksOutOfRange","filter","brk","isOut","otherBreak","from","to","toUpperCase","eventName","seriesGappedPath","currentDataGrouping","groupingSize","gapSize","slice","current","next","gapUnit","basePointRange","xRange","splice","isNull","stacking","stack","stacks","stackKey","stackLabels","total","getGraphPath","compose","AxisClass","SeriesClass","keepProps","seriesProto","prototype","gappedPath","isInBreak","val","repeat","Infinity","test","inclusive","lin2Val","nval","len","val2Lin","constructor","findBreakAt","b","testKeep","inbrk","keep","ret","showPoints","redraw","Object","userOptions","forceRedraw","val2lin","lin2val","setExtremes","newMin","newMax","animation","eventArguments","axisBreak","call","setAxisTranslation","unitLength","breakArrayT","pointRangePadding","inBrk","userMin","max","userMax","start","value","move","size","breakSize","sort","a","staticScale","transA","minPixelPadding","minPointOffset","chart","Axis","GridAxisSide","dateFormats","defined","erase","merge","timeUnits","wrap","isObject","getMaxLabelDimensions","ticks","dimensions","width","height","pos","tick","labelHeight","labelWidth","label","getBBox","textStr","textPxLength","Math","round","type","treeGrid","mapOfPosToGridNode","treeDepth","labels","indentation","wrapGetOffset","proceed","grid","columnsFirst","side","isColumn","columns","reverse","column","getOffset","onAfterGetTitlePosition","e","gridOptions","enabled","axisTitle","axisHeight","horiz","left","axisLeft","offset","opposite","top","axisTop","axisWidth","tickSize","titleWidth","xOption","title","yOption","titleMargin","margin","titleFontSize","renderer","fontMetrics","f","crispCorr","offAxis","bottom","titlePosition","onAfterInit","applyGridOptions","align","categories","showLastLabel","labelRotation","rotation","minTickInterval","columnIndex","columnOptions","isInternal","linkedTo","scrollbar","axes","coll","onAfterRender","firstTick","styledMode","slotWidth","style","css","maxLabelDimensions","rightWall","destroy","isOuterAxis","axisLine","lineWidth","linePath","getLinePath","startPoint","endPoint","tickLength","distance","marginRight","upperBorderEndPoint","upperBorderPath","lowerBorderEndPoint","chartWidth","toPixels","tickmarkOffset","lowerBorderStartPoint","lowerBorderPath","upperBorder","renderBorder","attr","stroke","lineColor","animate","d","lowerBorder","axisLineExtra","showAxis","render","hasRendered","linkedParent","tickMark","lastTick","hiddenLabels","pop","element","show","hiddenMarks","hide","mark","isLast","onAfterSetAxisTranslation","tickInfo","userLabels","pointRange","dateTimeLabelFormats","unitName","range","count","tickInterval","onAfterSetOptions","gridAxisOptions","className","hour","list","day","week","month","borderWidth","padding","fontSize","text","reserveSpace","textOverflow","units","tickPixelInterval","tickPositioner","parentInfo","unitIdx","unit","counts","unitRange","time","getTimeTicks","startOfWeek","minPadding","maxPadding","tickWidth","onAfterSetOptions2","onAfterSetScale","setScale","onAfterTickSize","labelPadding","cellHeight","onChartAfterSetChartSize","setAxisSize","onDestroy","keepEvents","onInit","borderColor","tickColor","GridAxisAdditions","onTickAfterGetLabelPosition","reversed","labelOpts","tickPos","nextTickPos","index","right","chartHeight","translate","lblMetrics","useHTML","lines","h","onTickLabelFormat","ctx","pointCopy","isFirst","data","p","is","seriesTypes","gantt","pointClass","setGanttPointAliases","onTrimTicks","categoryAxis","firstPos","secondPos","lastPos","beforeLastPos","linkedMin","linkedMax","startLessThanMin","endMoreThanMin","startLessThanMax","endMoreThanMax","isLinked","startOnTick","endOnTick","wrapUnsquish","arguments","Array","parentAxis","thisIndex","lastIndex","inverted","otherAxis","extraBorderLine","addClass","add","axisGroup","zIndex","E","timestamp","dateFormat","charAt","W","Date","unitsToOmit","format","set","firstDay","get","thursday","valueOf","firstThursday","floor","toString","ChartClass","TickClass","extend","getNode","id","parent","level","mapOfIdToChildren","after","before","node","depth","descendants","end","children","map","child","childStart","NaN","childEnd","milestone","getTree","getListOfParents","ids","listOfParents","reduce","prev","curr","indexOf","adoptedByRoot","orphan","parentExcluded","removeEvent","onTickInit","TreeGridTickAdditions","wrapGetLabelPosition","labelOptions","step","lbOptions","isTreeGrid","result","symbol","wrapRenderLabel","collapsed","tickGrid","tickOptions","icon","labelIcon","labelElement","axisGrid","axisOptions","symbolOptions","hasDescendants","isTreeGridElement","shouldRender","prefixClassName","prefixLevelClass","removeClass","RegExp","isCollapsed","renderLabelIcon","params","isNew","labelBox","xy","iconCenter","symbols","group","cursor","color","strokeWidth","translateX","translateY","styles","parentGroup","object","attachedTreeGridEvents","textDecoration","onTickHoverExit","toggleCollapse","tickProto","collapse","expand","posMappedNodes","Color","getColor","colorByPoint","colorIndexByPoint","colorIndex","mapOptionsToLevel","parentColor","parentColorIndex","colors","siblings","chartOptionsChart","colorCount","variateColor","colorVariation","parse","brighten","getLevelOptions","defaults","converted","levels","item","levelIsConstant","setTreeValues","tree","idRoot","mapIdToNode","nodeRoot","optionsPoint","childrenTotal","levelDynamic","name","newOptions","isLeaf","updateRootId","rootId","rootNode","GridAxis","Tree","TreeGridTick","TU","TickConstructor","isString","getBreakFromNode","collapseEnd","collapseStart","getTreeGridFromData","uniqueNames","numberOfSeries","collapsedNodes","mapOfIdToNode","uniqueNamesEnabled","posIterator","gridNode","parentNode","parentGridNode","nodes","updateYValuesAndTickPos","setValues","diff","seriesIndex","onBeforeRender","target","some","isDirtyData","arr","s","optionsToObject","hasNames","axisData","x2","setData","wrapGenerateTick","levelOptions","category","parameters","addLabel","wrapInit","TreeGridAxisAdditions","concat","n","fontWeight","wrapSetTickInterval","dataMin","dataMax","getTickPositions","linkedParentExtremes","getExtremes","wrapRedraw","axisProps","utils","setCollapsedStatus","dataPoint","roundedMin","roundedMax","ceil","TreeGridAxis","G","Chart","Series","Tick"],"mappings":"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"}